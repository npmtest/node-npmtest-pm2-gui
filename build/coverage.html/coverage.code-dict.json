{"/home/travis/build/npmtest/node-npmtest-pm2-gui/test.js":"/* istanbul instrument in package npmtest_pm2_gui */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/lib.npmtest_pm2_gui.js":"/* istanbul instrument in package npmtest_pm2_gui */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_pm2_gui = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_pm2_gui = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-pm2-gui && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_pm2_gui */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_pm2_gui\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_pm2_gui.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_pm2_gui.rollup.js'] =\n            local.assetsDict['/assets.npmtest_pm2_gui.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_pm2_gui.__dirname + '/lib.npmtest_pm2_gui.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/node_modules/pm2-gui/pm2-gui.js":"var chalk = require('chalk')\nvar path = require('path')\nvar fs = require('fs')\nvar _ = require('lodash')\nvar socketIO = require('socket.io')\nvar inquirer = require('inquirer')\nvar Monitor = require('./lib/monitor')\nvar Log = require('./lib/util/log')\nvar Web = require('./web/index')\nvar layout = require('./lib/blessed-widget/layout')\n\nif (path.basename(process.mainModule.filename, '.js') === 'pm2-gui') {\n  var cmd, file\n  if (process.argv.length > 2) {\n    cmd = process.argv[2]\n  }\n  if (process.argv.length > 3) {\n    file = process.argv[3]\n  }\n  cmd = cmd || 'start'\n\n  switch (cmd) {\n    case 'start':\n      startWebServer(file)\n      break\n    case 'agent':\n      startAgent(file)\n      break\n    case 'mon':\n      dashboard(file)\n      break\n    default:\n      Log({\n        level: 0,\n        prefix: true\n      })\n      console.error('Command', cmd, 'is not supported!')\n      break\n  }\n}\n\nexports.startWebServer = startWebServer\nexports.startAgent = startAgent\nexports.dashboard = dashboard\nexports.exitGraceful = exitGraceful\n\nfunction startWebServer (confFile) {\n  var monitor = slave({\n    confFile: confFile\n  })\n  var options = monitor.options\n\n  options.port = options.port || 8088\n  var server = Web({\n    middleware: function (req, res, next) {\n      req._config = options\n      next()\n    },\n    port: options.port\n  })\n\n  monitor.sockio = socketIO(server, {\n    origins: options.origins || '*:*'\n  })\n  monitor.run()\n  console.info('Web server is listening on 127.0.0.1:' + options.port)\n}\n\nfunction startAgent (confFile) {\n  var monitor = slave({\n    confFile: confFile\n  })\n\n  var options = monitor.options\n  options.agent = options.agent || {}\n  if (options.agent.offline) {\n    console.error('Agent is offline, can not start it.')\n    return process.exit(0)\n  }\n  options.port = options.port || 8088\n  var sockio = socketIO()\n  sockio.listen(options.port, {\n    origins: options.origins || '*:*'\n  })\n  monitor.sockio = sockio\n  monitor.run()\n  console.info('Socket.io server is listening on 0.0.0.0:' + options.port)\n}\n\nfunction dashboard (confFile) {\n  // restore cursor\n  process.on('exit', function () {\n    process.stdout.write('\\u001b[?25h')\n  })\n  var monitor = slave({\n    confFile: confFile\n  })\n  var options = _.clone(monitor.options)\n  var q = Monitor.available(options)\n\n  if (!q) {\n    console.error('No agent is online, can not start it.')\n    return process.exit(0)\n  }\n  var ql = q.choices.length\n  if (ql === 1) {\n    if (q.choices[0].short !== 'localhost') {\n      console.info('There is just one remoting server online, try to connect it.')\n    }\n    return _connectToDashboard(monitor, options, Monitor.parseConnectionString(q.choices[0].value))\n  }\n  if (!options.agent || !options.agent.offline) {\n    q.choices.splice(ql - 1, 0, new inquirer.Separator())\n  }\n\n  console.info('Remoting servers are online, choose one you are intrested in.')\n  console.log('')\n  inquirer.prompt(q).then(function (answers) {\n    console.log('')\n    _connectToDashboard(monitor, options, Monitor.parseConnectionString(answers.socket_server))\n  })\n}\n\nfunction exitGraceful (code, signal) {\n  code = code || 0\n  if (signal !== '-f') {\n    console.debug('Slave has exited, code: ' + code + ', signal: ' + (signal || 'NULL'))\n  }\n  var fds = 0\n\n  function tryToExit () {\n    if ((fds & 1) && (fds & 2)) {\n      process.exit(code)\n    }\n  }\n\n  [process.stdout, process.stderr].forEach(function (std) {\n    var fd = std.fd\n    if (!std.bufferSize) {\n      fds = fds | fd\n    } else {\n      std.write && std.write('', function () {\n        fds = fds | fd\n        tryToExit()\n      })\n    }\n  })\n  tryToExit()\n}\n\nfunction slave (options) {\n  process.title = 'pm2-gui slave'\n  options = options || {}\n  var confFile = options.confFile\n  if (!confFile) {\n    confFile = path.resolve(__dirname, './pm2-gui.ini')\n\n    if (!fs.existsSync(confFile)) {\n      console.error(chalk.bold(confFile), 'does not exist!')\n      return process.exit(0)\n    }\n  }\n  var monitor = Monitor({\n    confFile: confFile\n  })\n\n  Log(monitor.options.log)\n\n  console.log(chalk.cyan(\n    '\\n' +\n    '█▀▀█ █▀▄▀█ █▀█ ░░ ▒█▀▀█ ▒█░▒█ ▀█▀\\n' +\n    '█░░█ █░▀░█ ░▄▀ ▀▀ ▒█░▄▄ ▒█░▒█ ▒█░\\n' +\n    '█▀▀▀ ▀░░░▀ █▄▄ ░░ ▒█▄▄█ ░▀▄▄▀ ▄█▄\\n'))\n\n  process.on('SIGTERM', shutdown)\n  process.on('SIGINT', shutdown)\n  process.on('SIGHUP', restart)\n  process.on('uncaughtException', caughtException)\n  process.on('exit', exitGraceful)\n\n  function shutdown (code, signal) {\n    console.info('Shutting down....')\n    monitor.quit()\n    console.info('Shutdown complete!')\n    exitGraceful(code, '-f')\n  }\n\n  function restart () {\n    if (process.send) {\n      process.send({\n        action: 'restart'\n      })\n    } else {\n      console.error('No IPC found, could not restart monitor, shutting down.')\n      shutdown(1)\n    }\n  }\n\n  function caughtException (err) {\n    console.error(err.stack)\n    shutdown(1)\n  }\n\n  return monitor\n}\n\nfunction _connectToDashboard (monitor, options, connection) {\n  connection = _.extend({}, options, connection)\n  if (!!~['127.0.0.1', '0.0.0.0', 'localhost'].indexOf(connection.hostname)) { // eslint-disable-line no-extra-boolean-cast\n    return monitor.connect(connection, function (socket) {\n      console.info('Agent is online, try to connect it in dashboard directly.')\n      layout(connection).render(monitor)\n    }, function (err, socket) {\n      if (err === 'unauthorized') {\n        console.error('There was an error with the authentication:', err)\n        return process.exit(0)\n      }\n      console.warn('Agent is offline, try to start it.')\n      var sockio = socketIO()\n      sockio.listen(connection.port, {\n        origins: options.origins || '*:*'\n      })\n      monitor.sockio = sockio\n      monitor.run()\n      layout(connection).render(monitor)\n    })\n  }\n\n  layout(connection).render(monitor)\n}\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/node_modules/pm2-gui/lib/monitor.js":"var fs = require('fs')\nvar path = require('path')\nvar _ = require('lodash')\nvar chalk = require('chalk')\nvar ansiHTML = require('ansi-html')\nvar totalmem = require('os').totalmem()\nvar pidusage = require('pidusage')\nvar url = require('url')\nvar socketIOClient = require('socket.io-client')\nvar pm = require('./pm')\nvar stat = require('./stat')\nvar conf = require('./util/conf')\nvar Log = require('./util/log')\nvar defConf\n\nmodule.exports = Monitor\n\n/**\n * Monitor of project monitor web.\n * @param options\n * @returns {Monitor}\n * @constructor\n */\nfunction Monitor (options) {\n  if (!(this instanceof Monitor)) {\n    return new Monitor(options)\n  }\n\n  // Initialize...\n  this._init(options)\n}\n\nMonitor.ACCEPT_KEYS = ['pm2', 'refresh', 'daemonize', 'readonly', 'max_restarts', 'port', 'log', 'agent', 'remotes', 'origins']\nMonitor.DEF_CONF_FILE = 'pm2-gui.ini'\nMonitor.PM2_DAEMON_PROPS = ['DAEMON_RPC_PORT', 'DAEMON_PUB_PORT']\n\n/**\n * Run socket.io server.\n */\nMonitor.prototype.run = function () {\n  this._noClient = true\n\n  this._tails = {}\n  this._usages = {}\n\n  // Observe PM2\n  this._observePM2()\n\n  this._listeningSocketIO()\n}\n\n/**\n * Quit monitor.\n * @return {[type]} [description]\n */\nMonitor.prototype.quit = function () {\n  if (this.pm2Sock) {\n    console.debug('Closing pm2 pub emitter socket.')\n    this.pm2Sock.close()\n  }\n  if (this._sockio) {\n    console.debug('Closing socket.io server.')\n    this._sockio.close()\n\n    console.debug('Destroying tails.')\n    this._killTailProcess()\n  }\n}\n\n/**\n * Connect to socket.io server.\n * @param  {String} ns the namespace.\n * @param  {Function} success\n * @param  {Function} failure\n */\nMonitor.prototype.connect = function (options, success, failure) {\n  if (!options.port) {\n    throw new Error('Port is required!')\n  }\n  var serverUri = Monitor.toConnectionString(options)\n\n  success = _.once(success)\n  failure = _.once(failure)\n\n  console.info('Connecting to', serverUri)\n  var socket = socketIOClient(serverUri)\n  socket.on('connect', function () {\n    success(socket)\n  })\n\n  socket.on('error', function (err) {\n    !failure(err, socket)\n  })\n\n  socket.on('connect_error', function (err) {\n    !failure(err, socket)\n  })\n}\n\n/**\n * Resolve home path.\n * @param {String} pm2Home\n * @returns {*}\n * @private\n */\nMonitor.prototype._resolveHome = function (pm2Home) {\n  if (pm2Home && pm2Home.indexOf('~/') === 0) {\n    // Get root directory of PM2.\n    pm2Home = process.env.PM2_HOME || path.resolve(process.env.HOME || process.env.HOMEPATH, pm2Home.substr(2))\n\n    // Make sure exist.\n    if (!pm2Home || !fs.existsSync(pm2Home)) {\n      throw new Error('PM2 root can not be located, try to initialize PM2 by executing `pm2 ls` or set environment variable vi `export PM2_HOME=[ROOT]`.')\n    }\n  }\n  return pm2Home\n}\n\n/**\n * Initialize options and configurations.\n * @private\n */\nMonitor.prototype._init = function (options) {\n  options = options || {}\n\n  defConf = conf.File(options.confFile || path.resolve(__dirname, '..', Monitor.DEF_CONF_FILE)).loadSync().valueOf()\n  defConf = _.pick.call(null, defConf, Monitor.ACCEPT_KEYS)\n\n  options = _.pick.apply(options, Monitor.ACCEPT_KEYS).valueOf()\n  options = _.defaults(options, defConf)\n\n  options.pm2 = this._resolveHome(options.pm2)\n  Log(options.log)\n\n  // Load PM2 config.\n  var pm2ConfPath = path.join(options.pm2, 'conf.js')\n  var fbMsg = ''\n  try {\n    options.pm2Conf = require(pm2ConfPath)(options.pm2)\n    if (!options.pm2Conf) {\n      throw new Error(404)\n    }\n  } catch (err) {\n    fbMsg = 'Can not load PM2 config, the file \"' + pm2ConfPath + '\" does not exist or empty, fallback to auto-load by pm2 home. '\n    console.warn(fbMsg)\n    options.pm2Conf = {\n      DAEMON_RPC_PORT: path.resolve(options.pm2, 'rpc.sock'),\n      DAEMON_PUB_PORT: path.resolve(options.pm2, 'pub.sock'),\n      PM2_LOG_FILE_PATH: path.resolve(options.pm2, 'pm2.log')\n    }\n  }\n\n  Monitor.PM2_DAEMON_PROPS.forEach(function (prop) {\n    var val = options.pm2Conf[prop]\n    if (!val || !fs.existsSync(val)) {\n      throw new Error(fbMsg + 'Unfortunately ' + (val || prop) + ' can not found, please makesure that your pm2 is running and the home path is correct.')\n    }\n  })\n\n  // Bind socket.io server to context.\n  if (options.sockio) {\n    this.sockio = options.sockio\n    delete options.sockio\n  }\n\n  // Bind to context.\n  this.options = options\n  Object.freeze(this.options)\n}\n\n/**\n * Connection event of `sys` namespace.\n * @param {Socket} socket\n * @private\n */\nMonitor.prototype._connectSysSock = function (socket) {\n  var self = this\n  // Still has one client connects to server at least.\n  self._noClient = false\n\n  socket.on('disconnect', function () {\n    // Check connecting client.\n    self._noClient = self._sockio.of(conf.NSP.SYS).sockets.length === 0\n  })\n\n  // Trigger actions of process.\n  socket.on('action', function (action, id) {\n    var prefix = '[pm2:' + id + ']'\n    console.debug(prefix, action, 'sending to pm2 daemon...')\n    if (self.options.readonly) {\n      console.warn(prefix, 'denied, readonly!')\n      return socket.emit('action', id, 'Can not complete the action due to denied by server, it is readonly!')\n    }\n    pm.action(self.options.pm2Conf.DAEMON_RPC_PORT, action, id, function (err, forceRefresh) {\n      if (err) {\n        console.error(action, err.message)\n        return socket.emit('action', id, 'Can not complete the action due to ' + err.message)\n      }\n      console.debug(prefix, action, 'completed!')\n      forceRefresh && self._throttleRefresh()\n    })\n  })\n  sendProcs()\n  socket.on('procs', sendProcs)\n  self._pm2Ver(socket)\n  this._sysStat && this._broadcast('system_stat', this._sysStat)\n\n  // Grep system states once and again.\n  if (this._status !== 'R') {\n    this._nextTick(this.options.refresh || 5000)\n  }\n\n  function sendProcs () {\n    self._procs && socket.emit(typeof self._procs === 'string' ? 'info' : 'procs', self._procs)\n  }\n}\n\n/**\n * Connection event of `log` namespace.\n * @param {socket.io} socket\n * @private\n */\nMonitor.prototype._connectLogSock = function (socket) {\n  var self = this\n\n  // Emit error.\n  function emitError (err, pmId, keepANSI) {\n    var data = {\n      pm_id: pmId,\n      msg: keepANSI ? chalk.red(err.message) : '<span style=\"color: #ff0000\">Error: ' + err.message + '</span>'\n    }\n    self._broadcast.call(self, 'log', data, conf.NSP.LOG) // eslint-disable-line no-useless-call\n  }\n\n  function startTailProcess (pmId, keepANSI) {\n    socket._pm_id = pmId\n\n    if (self._tails[pmId]) {\n      return\n    }\n\n    // Tail logs.\n    pm.tail({\n      sockPath: self.options.pm2Conf.DAEMON_RPC_PORT,\n      logPath: self.options.pm2Conf.PM2_LOG_FILE_PATH,\n      pm_id: pmId\n    }, function (err, lines) {\n      if (err) {\n        return emitError(err, pmId, keepANSI)\n      }\n      // Emit logs to clients.\n      var data = {\n        pm_id: pmId,\n        msg: lines.map(function (line) {\n          if (!keepANSI) {\n            line = line.replace(/\\s/, '&nbsp;')\n            return '<span>' + ansiHTML(line) + '</span>'\n          } else {\n            return line\n          }\n        }).join(keepANSI ? '\\n' : '')\n      }\n      self._broadcast.call(self, 'log', data, conf.NSP.LOG) // eslint-disable-line no-useless-call\n    }, function (err, tail) {\n      if (err) {\n        return emitError(err, pmId, keepANSI)\n      }\n      if (!tail) {\n        return emitError(new Error('No log can be found.'), pmId, keepANSI)\n      }\n\n      console.info('[pm2:' + pmId + ']', 'tail starting...')\n      self._tails[pmId] = tail\n    })\n  }\n\n  socket.on('disconnect', self._killTailProcess.bind(self))\n  socket.on('tail_kill', self._killTailProcess.bind(self))\n  socket.on('tail', startTailProcess)\n  console.info('Connected to ' + socket.nsp.name + '!')\n}\n\n/**\n * Connection event of `proc` namespace.\n * @param {socket.io} socket\n * @private\n */\nMonitor.prototype._connectProcSock = function (socket) {\n  var self = this\n  // Emit error.\n  function emitError (err, pid) {\n    var data = {\n      pid: pid,\n      msg: '<span style=\"color: #ff0000\">Error: ' + err.message + '</span>'\n    }\n    self._broadcast.call(self, 'proc', data, conf.NSP.PROC) // eslint-disable-line no-useless-call\n  }\n\n  function killObserver () {\n    var socks = self._sockio.of(conf.NSP.PROC).sockets\n    var canNotBeDeleted = {}\n\n    if (Array.isArray(socks) && socks.length > 0) {\n      socks.forEach(function (sock) {\n        if (sock._pid) {\n          canNotBeDeleted[sock._pid.toString()] = 1\n        }\n      })\n    }\n\n    for (var pid in self._usages) {\n      var timer\n      if (!canNotBeDeleted[pid] && (timer = self._usages[pid])) {\n        clearInterval(timer)\n        delete self._usages[pid]\n        console.debug('[pid:' + pid + ']', 'cpu and memory observer destroyed!')\n      }\n    }\n  }\n\n  function runObserver (pid) {\n    socket._pid = pid\n\n    var pidStr = pid.toString()\n    if (self._usages[pidStr]) {\n      return\n    }\n\n    console.debug('[pid:' + pidStr + ']', 'cpu and memory observer is running...')\n\n    function runTimer () {\n      pidusage.stat(pid, function (err, stat) {\n        if (err) {\n          clearInterval(self._usages[pidStr])\n          delete self._usages[pidStr]\n          return emitError.call(self, err, pid)\n        }\n        stat.memory = stat.memory * 100 / totalmem\n\n        var data = {\n          pid: pid,\n          time: Date.now(),\n          usage: stat\n        }\n        self._broadcast.call(self, 'proc', data, conf.NSP.PROC) // eslint-disable-line no-useless-call\n      })\n    }\n\n    self._usages[pidStr] = setInterval(runTimer, 3000)\n    runTimer(this)\n  }\n\n  socket.on('disconnect', killObserver)\n  socket.on('proc', runObserver)\n  console.info('Connected to ' + socket.nsp.name + '!')\n}\n\n/**\n * Grep system state loop\n * @param {Number} tick\n * @private\n */\nMonitor.prototype._nextTick = function (tick, continuously) {\n  // Return it if worker is running.\n  if (this._status === 'R' && !continuously) {\n    return\n  }\n  // Running\n  this._status = 'R'\n  console.debug('monitor heartbeat per', tick + 'ms')\n  // Grep system state\n  this._systemStat(function () {\n    // If there still has any client, grep again after `tick` ms.\n    if (!this._noClient) {\n      return setTimeout(this._nextTick.bind(this, tick, true), tick)\n    }\n    // Stop\n    delete this._status\n    console.debug('monitor heartbeat destroyed!')\n  })\n}\n\n/**\n * Grep system states.\n * @param {Function} cb\n * @private\n */\nMonitor.prototype._systemStat = function (cb) {\n  stat.cpuUsage(function (err, cpuUsage) {\n    if (err) {\n      // Log only.\n      console.error('Can not load system/cpu/memory information: ', err.message)\n    } else {\n      // System states.\n      this._sysStat = _.defaults(_(stat).pick('cpus', 'arch', 'hostname', 'platform', 'release', 'uptime', 'memory').clone(), {\n        cpu: cpuUsage\n      })\n      this._broadcast.call(this, 'system_stat', this._sysStat) // eslint-disable-line no-useless-call\n    }\n    cb.call(this)\n  }, this)\n}\n\n/**\n * Observe PM2\n * @private\n */\nMonitor.prototype._observePM2 = function () {\n  var pm2Daemon = this.options.pm2Conf.DAEMON_PUB_PORT\n  console.info('Connecting to pm2 daemon:', pm2Daemon)\n  this.pm2Sock = pm.sub(pm2Daemon, function (data) {\n    console.info(chalk.magenta(data.event), data.process.name + '-' + data.process.pm_id)\n    this._throttleRefresh()\n  }, this)\n\n  // Enforce a refresh operation if RPC is not online.\n  this._throttleRefresh()\n}\n\n/**\n * Throttle the refresh behavior to avoid refresh bomb\n * @private\n */\nMonitor.prototype._throttleRefresh = function () {\n  if (this._throttle) {\n    clearTimeout(this._throttle)\n  }\n  this._throttle = setTimeout(function (ctx) {\n    ctx._throttle = null\n    ctx._refreshProcs()\n  }, 500, this)\n}\n\n/**\n * Refresh processes\n * @private\n */\nMonitor.prototype._refreshProcs = function () {\n  pm.list(this.options.pm2Conf.DAEMON_RPC_PORT, function (err, procs) {\n    if (err) {\n      return this._broadcast('info', 'Can not connect to pm2 daemon, ' + err.message)\n    }\n    // Wrap processes and cache them.\n    this._procs = procs.map(function (proc) {\n      proc.pm2_env = proc.pm2_env || {\n        USER: 'UNKNOWN'\n      }\n      var pm2Env = {\n        user: proc.pm2_env.USER\n      }\n\n      for (var key in proc.pm2_env) {\n        // Ignore useless fields.\n        if (key.slice(0, 1) === '_' ||\n          key.indexOf('axm_') === 0 || !!~['versioning', 'command'].indexOf(key) ||\n          key.charCodeAt(0) <= 90) {\n          continue\n        }\n        pm2Env[key] = proc.pm2_env[key]\n      }\n      proc.pm2_env = pm2Env\n      return proc\n    })\n    // Emit to client.\n    this._broadcast('procs', this._procs)\n  }, this)\n}\n\n/**\n * Get PM2 version and return it to client.\n * @private\n */\nMonitor.prototype._pm2Ver = function (socket) {\n  var pm2RPC = this.options.pm2Conf.DAEMON_RPC_PORT\n  console.info('Fetching pm2 version:', pm2RPC)\n  pm.version(pm2RPC, function (err, version) {\n    socket.emit('pm2_ver', (err || !version) ? '0.0.0' : version)\n  })\n}\n\n/**\n * Broadcast to all connected clients.\n * @param {String} event\n * @param {Object} data\n * @param {String} nsp\n * @private\n */\nMonitor.prototype._broadcast = function (event, data, nsp) {\n  nsp = nsp || conf.NSP.SYS\n\n  if (this._noClient) {\n    return console.debug('No client is connecting, ignore broadcasting', event, 'to', nsp)\n  }\n  console.debug('Broadcasting', event, 'to', nsp)\n  this._sockio.of(nsp).emit(event, data)\n}\n\n/**\n * Destroy tails.\n * @param  {Number} pm_id\n * @return {[type]}\n */\nMonitor.prototype._killTailProcess = function (pmId) {\n  var self = this\n\n  function killTail (id) {\n    var tail = self._tails[id]\n    if (!tail) {\n      return\n    }\n    try {\n      tail.kill('SIGTERM')\n    } catch (err) {}\n\n    delete self._tails[id]\n    console.info('[pm2:' + id + ']', 'tail destroyed!')\n  }\n  if (!isNaN(pmId)) {\n    return killTail(pmId)\n  }\n\n  var socks = self._sockio.of(conf.NSP.LOG).sockets\n  var canNotBeDeleted = {}\n  if (socks && socks.length > 0) {\n    socks.forEach(function (sock) {\n      canNotBeDeleted[sock._pm_id] = 1\n    })\n  }\n\n  for (var _id in self._tails) {\n    if (!canNotBeDeleted[_id]) {\n      killTail(_id)\n    }\n  }\n}\n\n/**\n * Listening all the nsp.\n */\nMonitor.prototype._listeningSocketIO = function () {\n  if (!this._sockio || this._sockio._listening) {\n    console.warn('Avoid duplicated listening!')\n    return\n  }\n\n  this._sockio._listening = true\n  for (var nsp in conf.NSP) {\n    this._sockio.of(conf.NSP[nsp]).on('connection', this['_connect' + (nsp[0] + nsp.toLowerCase().slice(1)) + 'Sock'].bind(this))\n    console.info('Listening connection event on', nsp.toLowerCase())\n  }\n\n  var auth\n  if (!(this.options.agent && (auth = this.options.agent.authorization))) {\n    return\n  }\n  this._sockio.use(function (socket, next) {\n    if (auth !== socket.handshake.query.auth) {\n      return next(new Error('unauthorized'))\n    }\n    next()\n  })\n}\n\n/**\n * List all available monitors.\n * @param  {Object} options\n * @return {Object}\n */\nMonitor.available = function (options) {\n  options.agent = options.agent || {}\n  var remotable = options.remotes && _.keys(options.remotes).length > 0\n\n  if (options.agent.offline && !remotable) {\n    return null\n  }\n\n  options.port = options.port || 8088\n\n  var q = {\n    name: 'socket_server',\n    message: 'Which socket server would you wanna connect to',\n    type: 'list',\n    choices: []\n  }\n  var wrapLocal = function () {\n    return {\n      value: (options.agent && options.agent.authorization ? options.agent.authorization + '@' : '') + '127.0.0.1:' + options.port,\n      short: 'localhost'\n    }\n  }\n  if (!remotable) {\n    q.choices = [wrapLocal()]\n    return q\n  }\n  var maxShortLength = 0\n  for (var remote in options.remotes) {\n    var connectionString = options.remotes[remote]\n    q.choices.push({\n      value: connectionString,\n      short: remote\n    })\n    maxShortLength = Math.max(maxShortLength, remote.length)\n  }\n  if (!options.agent.offline) {\n    var conn = wrapLocal()\n    q.choices.push(conn)\n    maxShortLength = Math.max(maxShortLength, conn.short.length)\n  }\n\n  if (q.choices.length > 1) {\n    q.choices.forEach(function (c) {\n      c.name = '[' + c.short + Array(maxShortLength - c.short.length + 1).join(options.blank || ' ') + '] '\n    })\n  }\n\n  return q\n}\n\n/**\n * Convert connection object to string.\n * @param  {Object} connection\n * @return {String}\n */\nMonitor.toConnectionString = function (connection) {\n  var uri = (connection.protocol || 'http:') + '//' + (connection.hostname || '127.0.0.1') + ':' + connection.port +\n    (connection.path || '') + (connection.namespace || '')\n\n  if (connection.authorization) {\n    uri += (uri.indexOf('?') > 0 ? '&' : '?') + 'auth=' + connection.authorization\n  }\n  return uri\n}\n\n/**\n * Parse connection string to an uri object.\n * @param  {String} connectionString\n * @return {Object}\n */\nMonitor.parseConnectionString = function (connectionString) {\n  var connection = {\n    port: 8088,\n    hostname: '127.0.0.1',\n    authorization: ''\n  }\n  var lastAt = connectionString.lastIndexOf('@')\n  if (lastAt >= 0) {\n    connection.authorization = connectionString.slice(0, lastAt)\n    connectionString = connectionString.slice(lastAt + 1)\n  }\n  if (!/^https?:\\/\\//i.test(connectionString)) {\n    connectionString = 'http://' + connectionString\n  }\n\n  if (connectionString) {\n    connectionString = url.parse(connectionString)\n    connection.hostname = connectionString.hostname\n    connection.port = connectionString.port\n    connection.path = (connectionString.path || '').replace(/^\\/+/, '')\n    connection.protocol = connectionString.protocol\n  }\n  return connection\n}\n\nObject.defineProperty(Monitor.prototype, 'sockio', {\n  set: function (io) {\n    if (this._sockio) {\n      this._sockio.close()\n    }\n    this._sockio = io\n    this._listeningSocketIO()\n  },\n  get: function () {\n    return this._sockio\n  }\n})\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/node_modules/pm2-gui/lib/pm.js":"var spawn = require('child_process').spawn\nvar fs = require('fs')\nvar _ = require('lodash')\nvar async = require('async')\nvar rpc = require('pm2-axon-rpc')\nvar axon = require('pm2-axon')\n\n/**\n * Forever lib.\n * @type {{}}\n */\nvar pm = module.exports = {}\n\nvar re_blank = /^[\\s\\r\\t]*$/\nvar allowedEvents = ['start', 'restart', 'exit', 'online']\n\n/**\n * Subscribe event BUS.\n * @param {String} sockPath\n * @param {Function} cb\n * @param {Object} context\n */\npm.sub = function (sockPath, cb, context) {\n  var sub = axon.socket('sub-emitter')\n  // Once awake from sleeping.\n  sub.on('log:*', function (e, d) {\n    // Do not subscribe it.\n    sub.off('log:*')\n    d.event = 'awake'\n    cb.call(context, d)\n  })\n\n  // Process events.\n  sub.on('process:*', function (e, d) {\n    if (d && !!~allowedEvents.indexOf(d.event)) {\n      cb.call(context, d)\n    }\n  })\n  sub.connect(sockPath)\n  return sub\n}\n\n/**\n * Get PM2 version.\n * @param {String} sockPath\n * @param {Function} cb\n */\npm.version = function (sockPath, cb) {\n  pm._rpc({\n    sockPath: sockPath,\n    events: [\n      ['getVersion', {}, cb]\n    ]\n  })\n}\n\n/**\n * List available processes.\n * @param {String} sockPath\n * @param {Function} cb\n * @param {Object} context\n */\npm.list = function (sockPath, cb, context) {\n  if (!fs.existsSync(sockPath)) {\n    return cb.call(context, [])\n  }\n  pm._rpc({\n    sockPath: sockPath,\n    events: [\n      ['getMonitorData', {}, cb]\n    ],\n    context: context || this\n  })\n}\n\n/**\n * Execute remote RPC events.\n * @param {Object} opts including:\n *  {String} sockPath\n *  {Object} context\n *  {Object} args\n *  {Object} events\n *    key: event name\n *    value: callback function\n * @private\n */\npm._rpc = function (opts) {\n  var req = axon.socket('req')\n  var rpcSock = req.connect(opts.sockPath)\n  var rpcClient = new rpc.Client(req)\n\n  // Connect RPC server.\n  rpcSock.on('connect', function () {\n    // Execute request.\n    var waterfalls = opts.events.map(function (event) {\n      return function (next) {\n        var cb = typeof event[event.length - 1] === 'function' ? event.pop() : null\n        if (cb) {\n          event.push(function () {\n            // Wrap arguments, no [].slice (avoid leak)!!!\n            var args = new Array(arguments.length)\n            for (var i = 0; i < args; i++) {\n              args[i] = arguments[i]\n            }\n            cb.apply(opts.context, arguments)\n            next()\n          })\n        }\n        rpcClient.call.apply(rpcClient, event)\n        if (!cb) {\n          next()\n        }\n      }\n    })\n    async.waterfall(waterfalls, function () {\n      rpcSock.close()\n    })\n  })\n}\n\n/**\n * Find process by pm_id.\n * @param {String} sockPath\n * @param {String} id\n * @param {Function} cb\n * @private\n */\npm._findById = function (sockPath, id, cb) {\n  pm.list(sockPath, function (err, procs) {\n    if (err) {\n      return cb(err)\n    }\n    if (!procs || procs.length === 0) {\n      return cb(new Error('No PM2 process running, the sockPath is \"' + sockPath + '\", please make sure it is existing!'))\n    }\n\n    var proc = _.find(procs, function (p) {\n      return p && p.pm_id === id\n    })\n\n    if (!proc) {\n      return cb(new Error('Cannot find pm process by pm_id: ' + id))\n    }\n\n    cb(null, proc)\n  }, true)\n}\n\n/**\n * Trigger actions of process by pm_id.\n * @param {String} sockPath\n * @param {String} id\n * @param {Function} cb\n */\npm.action = function (sockPath, action, id, cb) {\n  if (id === 'all') {\n    pm.list(sockPath, function (err, procs) {\n      if (err) {\n        return cb(err)\n      }\n      if (!procs || procs.length === 0) {\n        return cb(new Error('No PM2 process running, the sockPath is \"' + sockPath + '\", please make sure it is existing!'))\n      }\n\n      async.map(procs, function (proc, next) {\n        pm._actionByPMId(sockPath, proc, action, next.bind(null, null))\n      }, cb)\n    })\n  } else {\n    pm._findById(sockPath, id, function (err, proc) {\n      if (err) {\n        return cb(err)\n      }\n      pm._actionByPMId(sockPath, proc, action, cb)\n    })\n  }\n}\n\n/**\n * Trigger actions of process by pm_id.\n * @param {String} sockPath\n * @param {Object} proc\n * @param {String} action\n * @param {Function} cb\n * @private\n */\npm._actionByPMId = function (sockPath, proc, action, cb) {\n  var noBusEvent = action === 'delete' && proc.pm2_env.status !== 'online'\n  var pmId = proc.pm_id\n\n  action += 'ProcessId'\n  var watchEvent = ['stopWatch', action, {\n    id: pmId\n  }, function () {}]\n\n  if (!!~['restart'].indexOf(action)) { // eslint-disable-line no-extra-boolean-cast\n    watchEvent.splice(0, 1, 'restartWatch')\n    watchEvent.pop()\n  }\n\n  var actionEvent = [action, pmId, function (err, sock) {\n    cb(err, noBusEvent)\n  }]\n\n  if (action === 'restartProcessId') {\n    actionEvent.splice(1, 1, {\n      id: pmId\n    })\n  }\n\n  pm._rpc({\n    sockPath: sockPath,\n    events: [\n      watchEvent,\n      actionEvent\n    ]\n  })\n}\n\n/**\n * Tail logs.\n * @param {Object} opts\n * @param {Function} each Iterator\n * @param {Function} cb\n * @returns {*}\n */\npm.tail = function (opts, each, cb) {\n  // Fetch the proccess that we need.\n  pm._findById(opts.sockPath, opts.pm_id, function (err, proc) {\n    if (err) {\n      return cb(err)\n    }\n    proc.pm2_log = opts.logPath\n    // Tail logs.\n    cb(null, pm._tailLogs(proc, each))\n  })\n}\n/**\n * Use linux `tail` command to grep logs.\n * @param {Object} proc\n * @param {Function} cb\n * @returns {*}\n * @private\n */\npm._tailLogs = function (proc, cb) {\n  var logs = {\n    'pm2': proc.pm2_log\n  }\n  if (proc.pm_log_path) {\n    logs.entire = proc.pm2_env.pm_log_path\n  } else {\n    if (proc.pm2_env.pm_out_log_path) {\n      logs.out = proc.pm2_env.pm_out_log_path\n    }\n    if (proc.pm2_env.pm_err_log_path) {\n      logs.err = proc.pm2_env.pm_err_log_path\n    }\n  }\n\n  var logFiles = []\n  for (var key in logs) {\n    var file = logs[key]\n    if (fs.existsSync(file)) {\n      logFiles.push(file)\n    }\n  }\n  if (logFiles.length === 0) {\n    return null\n  }\n  var tail = spawn('tail', ['-n', 20, '-f'].concat(logFiles), {\n    killSignal: 'SIGTERM',\n    detached: true,\n    stdio: ['ignore', 'pipe', 'pipe']\n  })\n\n  // Use utf8 encoding.\n  tail.stdio.forEach(function (stdio) {\n    stdio && stdio.setEncoding('utf8')\n  })\n\n  // stdout.\n  tail.stdout.on('data', function (data) {\n    var lines = []\n    data.split(/\\n/).forEach(function (line) {\n      if (!re_blank.test(line)) {\n        lines.push(line)\n      }\n    })\n    if (lines.length > 0) {\n      cb(null, lines)\n    }\n  })\n\n  // handle error.\n  tail.stderr.on('data', function (data) {\n    console.error(data.toString())\n    tail.disconnect()\n    cb(new Error(data.toString().replace(/\\n/, '')))\n  })\n  tail.unref()\n  return tail\n}\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/node_modules/pm2-gui/lib/stat.js":"var os = require('os')\n\n/**\n * System states\n * @type {{hostname: *, platform: *, arch: *, release: *, cpus, uptime, memory}}\n */\nvar stat = module.exports = {\n  /**\n   * Hostname, e.g.: localhost, TjatseMacProBook.local...\n   */\n  hostname: os.hostname(),\n  /**\n   * Platform, e.g.: darwin, win32, linux...\n   */\n  platform: os.platform(),\n  /**\n   * Architecture, e.g.: 64, 32...\n   */\n  arch: os.arch(),\n  /**\n   * Ver number of system.\n   */\n  release: os.release(),\n  /**\n   * List all CPUs.\n   * @returns {*}\n   */\n  get cpus () {\n    return os.cpus()\n  },\n  /**\n   * Uptime.\n   * @returns {*}\n   */\n  get uptime () {\n    return os.uptime()\n  },\n  /**\n   * System memory usage.\n   * @returns {{free: *, total: *, percentage: number}}\n   */\n  get memory () {\n    return {\n      free: os.freemem(),\n      total: os.totalmem(),\n      percentage: Math.round(100 * (1 - os.freemem() / os.totalmem()))\n    }\n  }\n}\n\n/**\n * System CPU usage percentage (total).\n * @param fn\n * @param context\n */\nstat.cpuUsage = function (fn, context) {\n  setTimeout(function (ctx, stat1) {\n    var stat2 = ctx.cpuInfo()\n    var perc = 100 * (1 - (stat2.idle - stat1.idle) / (stat2.total - stat1.total))\n    fn.call(context, null, perc.toFixed(2))\n  }, 1000, this, this.cpuInfo())\n}\n\n/**\n * System CPU usage detail information.\n * @returns {{idle: number, total: number}}\n */\nstat.cpuInfo = function () {\n  var cpus = this.cpus\n  var idle = 0\n  var total = 0\n  for (var i in cpus) {\n    idle += cpus[i].times.idle\n    for (var k in cpus[i].times) {\n      total += cpus[i].times[k]\n    }\n  }\n  return {\n    'idle': idle,\n    'total': total\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/node_modules/pm2-gui/lib/util/conf.js":"var fs = require('fs')\nvar _ = require('lodash')\n\nvar re_comment = /^\\s*;/\nvar re_setion = /^\\s*\\[([^\\]]+)\\]\\s*$/\nvar re_kv = /^([^=]+)=(.*)$/\nvar re_boolean = /^(true|false)$/i\n\n/**\n * Namespaces of socket.io\n * @type {{SYS: string, LOG: string, PROC: string}}\n */\nexports.NSP = {\n  SYS: '/sys',\n  LOG: '/log',\n  PROC: '/proc'\n}\n\n/**\n * Configurations\n * @type {[type]}\n */\nexports.File = File\n\n/**\n * Configurations store in a disk file.\n * @param {Object} options\n * @constructor\n */\nfunction File (options) {\n  if (!(this instanceof File)) {\n    return new File(options)\n  }\n\n  if (typeof options === 'string') {\n    options = {\n      file: options\n    }\n  }\n  options = _.assign({}, options || {})\n  if (!options.file) {\n    throw new Error('`file` is required.')\n  }\n  Object.freeze(options)\n  this.options = options\n}\n\n/**\n * Load data from file (sync).\n */\nFile.prototype.loadSync = function () {\n  if (!fs.existsSync(this.options.file)) {\n    this._data = {}\n    return this\n  }\n\n  var json = {}\n  var sec\n  fs.readFileSync(this.options.file, {\n    encoding: 'utf8'\n  }).split(/[\\r\\n]/).forEach(function (line) {\n    // Empty line.\n    if (!line) {\n      sec = null\n      return\n    }\n    // Remove comments.\n    if (re_comment.test(line)) {\n      return\n    }\n    var ms\n    // Sections.\n    if ((ms = line.match(re_setion)) && ms.length === 2) {\n      json[sec = ms[1].trim()] = {}\n      return\n    }\n\n    // Key-value pairs.\n    if ((ms = line.match(re_kv)) && ms.length === 3) {\n      var key = ms[1].trim()\n      var value = ms[2].trim()\n      // Parse boolean and number.\n      if (!isNaN(value)) {\n        value = parseFloat(value)\n      } else if (re_boolean.test(value)) {\n        value = value.toLowerCase() === 'true'\n      }\n      if (sec) {\n        json[sec][key] = value\n      } else {\n        json[key] = value\n      }\n    }\n  })\n\n  this._data = json\n  return this\n}\n\n/**\n * Save data to a disk file (sync).\n * @returns {File}\n */\nFile.prototype.saveSync = function () {\n  function wrapValue (key, value) {\n    return key + ' = ' + (typeof value === 'string' ? value : JSON.stringify(value)) + '\\n'\n  }\n  var ini = ''\n  for (var key in this._data) {\n    var value = this._data[key]\n    // TODO: Array type.\n    if (typeof value === 'object') {\n      ini += '[ ' + key + ' ]\\n'\n      for (var subKey in value) {\n        ini += wrapValue(subKey, value[subKey])\n      }\n      ini += '\\n'\n    }\n    ini += wrapValue(key, value)\n  }\n  fs.writeFileSync(this.options.file, ini)\n  return this\n}\n\n/**\n * Get data.\n * @returns {{}|*}\n */\nFile.prototype.valueOf = function () {\n  return this._data\n}\n\n/**\n * Get/set/remove key-value pairs.\n * @param {String} key\n * @param {Mixed} value\n * @param {Mixed} def\n * @returns {*}\n */\nFile.prototype.val = function (key, value, def) {\n  if (!key) {\n    return\n  }\n  // Load config from File.\n  this.loadSync()\n\n  if (typeof value === 'undefined') {\n    // Get config.\n    return this._data[key]\n  } else if (value == null) {\n    // Clear config.\n    delete this._data[key]\n    // Reset to default if necessary.\n    if (typeof def !== 'undefined') {\n      this._data[key] = def\n    }\n    return this.saveSync()\n  }\n\n  this._data[key] = value\n\n  // Save it.\n  this.saveSync()\n  return this\n}\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/node_modules/pm2-gui/lib/util/log.js":"var chalk = require('chalk')\n\nmodule.exports = function (options) {\n  options = options || {}\n  var lev = options.level\n  var hacks = ['debug', 'log', 'info', 'warn', 'error']\n\n  if ((typeof lev === 'string' && typeof (lev = hacks.indexOf(lev)) === 'undefined') || (isFinite(lev) && (lev < 0 || lev > hacks.length))) {\n    options.level = 0\n  }\n  options.level = !isNaN(lev) ? lev : 0\n\n  console.__level = options.level\n\n  if (console.__hacked) {\n    return\n  }\n\n  var colors = ['grey', '', 'green', 'yellow', 'red']\n  var consoled = {}\n\n  hacks.forEach(function (method) {\n    if (method === 'debug') {\n      consoled.debug = console.log\n      return\n    }\n    consoled[method] = console[method]\n  })\n\n  hacks.forEach(function (method, index) {\n    console[method] = function () {\n      if (index < console.__level) {\n        return\n      }\n      if (method !== 'log' && arguments.length > 0) {\n        arguments[0] = (options.prefix ? chalk.bold[colors[index]]('[' + method.toUpperCase() + '] ') : '') +\n        (options.date ? (new Date()).toLocaleString() + ' ' : '') + arguments[0]\n      }\n      consoled[method].apply(console, arguments)\n    }\n  })\n\n  console.__hacked = true\n}\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/node_modules/pm2-gui/web/index.js":"var express = require('express')\nvar session = require('express-session')\nvar path = require('path')\nvar http = require('http')\nvar router = require('../lib/util/router')\n\nmodule.exports = runServer\n\nfunction runServer (options) {\n  var app = express()\n  app.set('view engine', 'jade')\n  app.set('views', path.join(__dirname, 'templates/views'))\n  app.use(express.static(path.join(__dirname, 'public')))\n  app.use(session({\n    secret: 'pm2@gui',\n    resave: false,\n    saveUninitialized: true\n  }))\n  if (options.middleware) {\n    app.use(options.middleware)\n  }\n  router(app)\n\n  var server = http.Server(app)\n  server.listen(options.port)\n  return server\n}\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/node_modules/pm2-gui/lib/util/router.js":"var path = require('path')\nvar fs = require('fs')\n\nvar routes = []\n\n// bind actions.\nglobal.action = function (method, path, func) {\n  if (typeof method === 'function') {\n    func = method\n    method = 'get'\n    path = func.name\n  } else if (typeof path === 'function') {\n    func = path\n    path = func.name\n  }\n  if (typeof method !== 'string' || typeof path !== 'string' || typeof func !== 'function') {\n    throw new Error('Arguments of action() should be one of `[FUNCTION]` / `[METHOD], [FUNCTION]` / `[METHOD], [PATH], [FUNCTION]`.')\n  }\n  routes.push({\n    method: method,\n    path: '/' + (!!~['index', 'home', 'main'].indexOf(__route_root) ? '' : __route_root) + (path ? '/' + path : ''), // eslint-disable-line no-extra-boolean-cast, no-undef\n    fn: func\n  })\n}\n\nvar _cwd = path.resolve(__dirname, '../../', 'web/routes')\n// initialize.\nmodule.exports = function (server) {\n  fs.readdirSync(_cwd).forEach(function (f) {\n    if (path.extname(f) !== '.js') {\n      return\n    }\n    global.__route_root = path.basename(f, '.js')\n    require(path.resolve(_cwd, f))\n    delete global.__route_root\n  })\n  routes.forEach(function (route) {\n    route.path = route.path.replace(/\\/+/g, '/')\n    server[route.method](route.path, route.fn)\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/node_modules/pm2-gui/lib/blessed-widget/layout.js":"var blessed = require('blessed')\nvar chalk = require('chalk')\nvar async = require('async')\nvar _ = require('lodash')\nvar widgets = require('./widgets')\nvar conf = require('../util/conf')\nvar Log = require('../util/log')\n\nmodule.exports = Layout\n\nvar exiting = false\n/**\n * Create layout.\n * @param {Object} options\n */\nfunction Layout (options) {\n  if (!(this instanceof Layout)) {\n    return new Layout(options)\n  }\n  options = _.clone(options || {})\n  if (!options.hostname) {\n    options.hostname = '127.0.0.1'\n  }\n  if (!options.port) {\n    throw new Error('Port of socket.io server is required!')\n  }\n  options.sockets = options.sockets || {}\n  this.options = options\n  this._eles = {}\n  this._procCount = 0\n}\n\n/**\n * Render GUI.\n */\nLayout.prototype.render = function (monitor) {\n  var self = this\n  var options = this.options\n\n  // Preparing all socket.io clients.\n  async.series(Object.keys(conf.NSP).map(function (ns) {\n    return function (callback) {\n      var callbackOnce = _.once(callback)\n      var nsl = ns.toLowerCase()\n      if (options.sockets[nsl]) {\n        return callbackOnce()\n      }\n\n      monitor.connect(_.extend({\n        namespace: conf.NSP[ns]\n      }, options), function (socket) {\n        console.info('Connected to', socket.nsp)\n        callbackOnce(null, socket)\n      }, function (err, socket) {\n        if (err) {\n          return callbackOnce(new Error('Failed to connect to [' + ns + '] due to ' + err.message))\n        }\n      })\n    }\n  }), function (err, res) {\n    if (err) {\n      console.error(err.message)\n      return process.exit(0)\n    }\n    Log({\n      level: 1000\n    })\n    var connectedSockets = {}\n    res.forEach(function (socket) {\n      connectedSockets[socket.nsp.replace(/^\\/+/g, '')] = socket\n    })\n    self.sockets = _.extend(connectedSockets, options.sockets)\n    delete options.sockets\n\n    self._observe()\n    self._draw()\n\n    setInterval(function () {\n      self._bindProcesses()\n    }, 1000)\n  })\n}\n\n/**\n * Observe socket.io events.\n */\nLayout.prototype._observe = function () {\n  var self = this\n  console.info('Listening socket events...')\n  var socketSys = this._socket(conf.NSP.SYS)\n  socketSys.on('procs', function (procs) {\n    self._procs = {\n      data: procs,\n      tick: Date.now()\n    }\n    if (typeof self._procs === 'undefined') {\n      self._bindProcesses()\n    }\n  })\n  socketSys.emit('procs')\n\n  this._socket(conf.NSP.PROC).on('proc', function (proc) {\n    if (!self._usages || proc.pid !== self._usages.pid || self._usages.time === proc.time) {\n      return\n    }\n    self._usages.time = proc.time\n    self._usages.cpu.shift()\n    self._usages.cpu.push(Math.min(100, Math.max(proc.usage.cpu, 1)))\n    self._usages.mem.shift()\n    self._usages.mem.push(Math.min(100, Math.max(proc.usage.memory, 1)))\n  })\n\n  this._socket(conf.NSP.LOG).on('log', function (log) {\n    if (!self._eles.logs || self._lastLogPMId !== log.pm_id) {\n      return\n    }\n    self._eles.logs.log(log.msg)\n  })\n}\n\n/**\n * Bind processes to table.\n */\nLayout.prototype._bindProcesses = function () {\n  if (exiting || !this._eles.processes || !this._procs) {\n    return\n  }\n  if (this._procs.tick === this._procsLastTick) {\n    // Update tick only.\n    return setRows.call(this, true)\n  }\n\n  if (typeof this._procsLastTick === 'undefined') {\n    this._describeInfo(0)\n    this._eles.processes.rows.on('select', onSelect.bind(this))\n  }\n\n  this._procsLastTick = this._procs.tick\n\n  setRows.call(this, true)\n\n  function setRows (forceRefresh) {\n    var rows = []\n    var selectedIndex = this._eles.processes.rows.selected\n    var len = this._procs.data.length\n\n    this._procs.data.forEach(function (p, i) {\n      var pm2 = p.pm2_env\n      var index = '[' + i + '/' + len + ']'\n      rows.push([\n        ' ' + chalk.grey((index + Array(8 - index.length).join(' '))) + ' ' + p.name,\n        pm2.restart_time,\n        pm2.status !== 'online' ? '0s' : _fromNow(Math.ceil((Date.now() - pm2.pm_uptime) / 1000), true),\n        pm2.status === 'online' ? chalk.green('✔') : chalk.red('✘')\n      ])\n    })\n    this._eles.processes.setData({\n      headers: [' Name', 'Restarts', 'Uptime', ''],\n      rows: rows\n    })\n\n    selectedIndex = typeof selectedIndex !== 'undefined' ? selectedIndex : 0\n    var maxIndex = this._eles.processes.rows.items.length - 1\n    if (selectedIndex > maxIndex) {\n      selectedIndex = maxIndex\n    }\n    this._eles.processes.rows.select(selectedIndex)\n\n    if (forceRefresh) {\n      onSelect.call(this)\n    }\n  }\n\n  function onSelect (item, selectedIndex) {\n    if (!!item) { // eslint-disable-line no-extra-boolean-cast\n      var lastIndex = this._lastSelectedIndex\n\n      this._lastSelectedIndex = selectedIndex\n      if (selectedIndex !== lastIndex) {\n        this._describeInfo(selectedIndex)\n      }\n    }\n    this._cpuAndMemUsage(this._lastSelectedIndex || 0)\n    this._displayLogs(this._lastSelectedIndex || 0)\n    this.screen.render()\n  }\n}\n\n/**\n * Get description of a specified process.\n * @param  {Number} index the selected row index.\n */\nLayout.prototype._describeInfo = function (index) {\n  var pm2 = this._dataOf(index)\n  if (!pm2) {\n    return this._eles.json.setContent(_formatJSON({\n      message: 'There is no process running!'\n    }))\n  }\n  if (pm2.pm2_env && pm2.pm2_env.env) {\n    // Remove useless large-bytes attributes.\n    delete pm2.pm2_env.env['LS_COLORS']\n  }\n  delete pm2.monit\n  this._eles.json.setContent(_formatJSON(pm2))\n}\n\n/**\n * CPU and Memory usage of a specific process\n * @param  {Number} index the selected row index.\n */\nLayout.prototype._cpuAndMemUsage = function (index) {\n  var pm2 = this._dataOf(index)\n  if (!pm2) {\n    return\n  }\n  if (!this._usages) {\n    this._usages = {\n      mem: [],\n      cpu: []\n    }\n    var len = this._eles.cpu.width - 4\n    for (var i = 0; i < len; i++) {\n      this._usages.cpu.push(1)\n      this._usages.mem.push(1)\n    }\n  }\n  if (pm2.pid !== 0 && this._procCount === 2) {\n    this._procCount = -1\n    this._socket(conf.NSP.PROC).emit('proc', pm2.pid)\n  }\n  this._procCount++\n  this._usages.pid = pm2.pid\n\n  this._eles.cpu.setData(this._usages.cpu, 0, 100)\n  this._eles.cpu.setLabel('CPU Usage (' + (this._usages.cpu[this._usages.cpu.length - 1]).toFixed(2) + '%)')\n\n  this._eles.mem.setData(this._usages.mem, 0, 100)\n  this._eles.mem.setLabel('Memory Usage (' + (this._usages.mem[this._usages.mem.length - 1]).toFixed(2) + '%)')\n}\n\n/**\n * Display logs.\n * @param  {Number} index [description]\n * @return {[type]}       [description]\n */\nLayout.prototype._displayLogs = function (index) {\n  var pm2 = this._dataOf(index)\n  if (!pm2 || this._lastLogPMId === pm2.pm_id) {\n    return\n  }\n  this._killLogs()\n  this._socket(conf.NSP.LOG).emit('tail', this._lastLogPMId = pm2.pm_id, true)\n}\n\n/**\n * Kill `tail` process\n * @return {[type]}         [description]\n */\nLayout.prototype._killLogs = function () {\n  if (typeof this._lastLogPMId === 'undefined') {\n    return\n  }\n  this._socket(conf.NSP.LOG).emit('tail_kill', this._lastLogPMId)\n}\n\n/**\n * Get data by index.\n * @param  {Number} index\n * @return {Object}\n */\nLayout.prototype._dataOf = function (index) {\n  if (!this._procs || !Array.isArray(this._procs.data) || index >= this._procs.data.length) {\n    return null\n  }\n  return this._procs.data[index]\n}\n\n/**\n * Draw elements.\n */\nLayout.prototype._draw = function () {\n  console.info('Rendering dashboard...')\n  var self = this\n  var screen = blessed.Screen()\n  screen.title = 'PM2 Monitor'\n\n  var grid = _grid(screen)\n\n  // Processes.\n  this._eles.processes = grid.get(0, 0)\n  this._bindProcesses()\n\n  this._eles.cpu = grid.get(1, 0)\n  this._eles.mem = grid.get(1, 1)\n\n  // Logs.\n  this._eles.logs = grid.get(2, 0)\n\n  // Detail.\n  this._eles.json = grid.get(0, 2)\n  var offset = Math.round(this._eles.json.height * 100 / this._eles.json.getScrollHeight())\n  var dir\n  // Key bindings\n  screen.key('s', function (ch, key) {\n    if (exiting) {\n      return\n    }\n    var perc = Math.min((dir !== 'down' ? offset : 0) + self._eles.json.getScrollPerc() + 5, 100)\n    dir = 'down'\n    self._eles.json.setScrollPerc(perc)\n  })\n  screen.key('w', function (ch, key) {\n    if (exiting) {\n      return\n    }\n    var perc = Math.max(self._eles.json.getScrollPerc() - 5 - (dir !== 'up' ? offset : 0), 0)\n    dir = 'up'\n    self._eles.json.setScrollPerc(perc)\n  })\n\n  screen.key(['escape', 'q', 'C-c'], function (ch, key) {\n    if (exiting) {\n      return\n    }\n    exiting = true\n    this._killLogs()\n    screen.title = 'PM2 Monitor (Exiting...)'\n    screen.destroy()\n    screen.title = ''\n    screen.cursorReset()\n    setTimeout(function () {\n      // clear screen.\n      // process.stdout.write('\\u001B[2J\\u001B[0;0f')\n      process.exit(0)\n    }, 1000)\n  }.bind(this))\n\n  screen.render()\n  this.screen = screen\n}\n\n/**\n * Get socket.io object by namespace\n * @param  {String} ns\n */\nLayout.prototype._socket = function (ns) {\n  if (ns && this.sockets) {\n    return this.sockets[(ns || '').replace(/^\\/+/g, '').toLowerCase()]\n  }\n  return null\n}\n\n/**\n * Grid of screen elements.\n * @param {blessed.Screen} screen\n * @returns {*}\n * @private\n */\nfunction _grid (screen) {\n  var style = {\n    fg: '#013409',\n    label: {\n      bold: true,\n      fg: '#00500d'\n    },\n    border: {\n      fg: '#5e9166'\n    }\n  }\n  // Layout.\n  var grid = widgets.Grid({\n    rows: 3,\n    cols: 3,\n    margin: 0,\n    widths: [25, 25, 50],\n    heights: [35, 10, 55]\n  })\n  // Table of processes\n  grid.set({\n    row: 0,\n    col: 0,\n    colSpan: 2,\n    element: widgets.Table,\n    options: {\n      keys: true,\n      border: {\n        type: 'line'\n      },\n      style: style,\n      label: 'Processes (↑/↓ to move up/down, enter to select)',\n      widths: [35, 15, 20, 15]\n    }\n  })\n  // Sparkline of CPU\n  grid.set({\n    row: 1,\n    col: 0,\n    element: widgets.Sparkline,\n    options: {\n      border: {\n        type: 'line'\n      },\n      style: {\n        fg: '#bc6f0a',\n        label: {\n          bold: true,\n          fg: '#00500d'\n        },\n        border: {\n          fg: '#5e9166'\n        }\n      },\n      label: 'CPU Usage(%)'\n    }\n  })\n\n  // Sparkline of Memory\n  grid.set({\n    row: 1,\n    col: 1,\n    element: widgets.Sparkline,\n    options: {\n      border: {\n        type: 'line'\n      },\n      style: {\n        fg: '#6a00bb',\n        label: {\n          bold: true,\n          fg: '#00500d'\n        },\n        border: {\n          fg: '#5e9166'\n        }\n      },\n      label: 'Memory Usage(%)'\n    }\n  })\n\n  // Logs\n  grid.set({\n    row: 2,\n    col: 0,\n    colSpan: 2,\n    element: widgets.Log,\n    options: {\n      border: {\n        type: 'line'\n      },\n      style: style,\n      label: 'Logs'\n    }\n  })\n\n  // JSON data.\n  grid.set({\n    row: 0,\n    col: 2,\n    rowSpan: 3,\n    element: blessed.ScrollableBox,\n    options: {\n      label: 'Describe Info (w/s to move up/down)',\n      border: {\n        type: 'line'\n      },\n      style: style,\n      keys: true\n    }\n  })\n  grid.draw(screen)\n\n  return grid\n}\n\n/**\n * Pretty json data.\n * @param {Object} data\n * @returns {XML|*|string|void}\n * @private\n */\nfunction _formatJSON (data) {\n  data = JSON.stringify(typeof data !== 'string' ? data : JSON.parse(data), null, 2)\n\n  return data.replace(/(\"(\\\\u[a-zA-Z0-9]{4}|\\\\[^u]|[^\\\\\"])*\"(\\s*:)?|\\b(true|false|null)\\b|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)/g, function (m) {\n    var color = 'blue'\n    if (/^\"/.test(m)) {\n      color = ['magenta', 'green'][/:$/.test(m) ? 0 : 1]\n    } else if (/true|false/.test(m)) {\n      color = 'blue'\n    } else if (/null|undefined/.test(m)) {\n      color = 'blue'\n    }\n    return chalk[color](m)\n  })\n}\n\n/**\n * Wrap tick from now.\n * @param {Float} tick\n * @param {Boolean} tiny show all of it.\n * @returns {string}\n */\nfunction _fromNow (tick, tiny) {\n  if (tick < 60) {\n    return tick + 's'\n  }\n  var s = tick % 60 + 's'\n  if (tick < 3600) {\n    return parseInt(tick / 60) + 'm ' + s\n  }\n  var m = parseInt((tick % 3600) / 60) + 'm '\n  if (tick < 86400) {\n    return parseInt(tick / 3600) + 'h ' + m + (!tiny ? '' : s)\n  }\n  var h = parseInt((tick % 86400) / 3600) + 'h '\n  return parseInt(tick / 86400) + 'd ' + h + (!tiny ? '' : m + s)\n}\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/node_modules/pm2-gui/lib/blessed-widget/widgets.js":"// Inspired by the blessed-contrib, but more powerful and free.\n// (c) Tjatse\n\nvar blessed = require('blessed')\nvar util = require('util')\nvar re_stripANSI = /(?:(?:\\u001b\\[)|\\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\\u001b[A-M]/g\n\nexports.Grid = Grid\nexports.Table = Table\nexports.Sparkline = Sparkline\nexports.Log = Log\n\n/**\n * Grid cells.\n * @param {Object} options\n * @returns {Grid}\n * @constructor\n */\nfunction Grid (options) {\n  if (!(this instanceof Grid)) {\n    return new Grid(options)\n  }\n  options = util._extend({\n    margin: 2\n  }, options || {})\n\n  this.grids = []\n\n  for (var r = 0; r < options.rows; r++) {\n    this.grids[r] = []\n    for (var c = 0; c < options.cols; c++) {\n      this.grids[r][c] = {}\n    }\n  }\n\n  this.options = options\n}\n/**\n * Get instance in the specific row and column.\n * @param {Number} row\n * @param {Number} col\n * @returns {*}\n */\nGrid.prototype.get = function (row, col) {\n  return this.grids[row][col].instance\n}\n/**\n * Set element in the cell.\n * @param ele\n */\nGrid.prototype.set = function (ele) {\n  if (Array.isArray(ele)) {\n    for (var i = 0; i < ele.length; i++) {\n      this.set(ele[i])\n    }\n    return\n  }\n  this.grids[ele.row][ele.col] = util._extend({rowSpan: 1, colSpan: 1}, ele)\n}\n/**\n * Draw grid.\n * @param {blessed.screen} screen\n */\nGrid.prototype.draw = function (screen, rect) {\n  rect = rect || {\n    width: 100,\n    height: 100,\n    top: 0,\n    left: 0\n  }\n  var margin = this.options.margin\n  var widths = this.options.widths || []\n  var heights = this.options.heights || []\n  var cols = this.options.cols\n  var rows = this.options.rows\n\n  if (widths.length !== cols) {\n    var avg = (rect.width - margin) / cols\n    for (var c = 0; c < cols; c++) {\n      widths.push(avg)\n    }\n  }\n  if (heights.length !== rows) {\n    var avg = (rect.height - margin) / rows // eslint-disable-line no-redeclare\n    for (var r = 0; r < rows; r++) {\n      heights.push(avg)\n    }\n  }\n\n  for (var r = 0; r < rows; r++) { // eslint-disable-line no-redeclare\n    for (var c = 0; c < cols; c++) { // eslint-disable-line no-redeclare\n      var ele = this.grids[r][c]\n      if (!ele.element) {\n        continue\n      }\n\n      var factorWidth = (rect.width - margin) / 100\n      var factorHeight = (rect.height - margin) / 100\n      var width = widths.slice(c, c + ele.colSpan).reduce(_reduce) * factorWidth\n      var height = heights.slice(r, r + ele.rowSpan).reduce(_reduce) * factorHeight\n      var top = rect.top + margin / 2 + (r === 0 ? 0 : heights.slice(0, r).reduce(_reduce)) * factorHeight\n      var left = rect.left + margin / 2 + (c === 0 ? 0 : widths.slice(0, c).reduce(_reduce)) * factorWidth\n\n      if (ele.element instanceof Grid) {\n        ele.element.draw(screen, {\n          width: width,\n          height: height,\n          top: top,\n          left: left\n        })\n      } else {\n        screen.append(ele.instance = ele.element(util._extend(ele.options || {}, {\n          top: top + '%',\n          left: left + '%',\n          width: width + '%',\n          height: height + '%'\n        })))\n      }\n    }\n  }\n}\n\n/**\n * Table list.\n * @param {Object} options\n * @returns {Table}\n * @constructor\n */\nfunction Table (options) {\n  if (!(this instanceof Table)) {\n    return new Table(options)\n  }\n\n  this.options = options || {}\n  this.options.tags = true\n\n  blessed.Box.call(this, this.options)\n\n  this.rows = blessed.list(util._extend(this.options.rows || {}, {\n    height: 0,\n    top: 1,\n    width: 0,\n    left: 0,\n    selectedFg: '#fcfbac',\n    selectedBg: '#398cc6',\n    fg: '#333',\n    keys: true\n  }))\n  this.append(this.rows)\n}\n\nutil.inherits(Table, blessed.Box)\n\n/**\n * Inherits from blessed.Box\n */\nTable.prototype.render = function () {\n  this.rows.focus()\n  this.rows.width = this.width - 2\n  this.rows.height = this.height - 4\n  blessed.Box.prototype.render.call(this, this.options)\n}\n\n/**\n * Bind data to Table.\n * @param {Object} data\n */\nTable.prototype.setData = function (data) {\n  var widths = this.options.widths\n  var def = true\n  if (!widths) {\n    widths = 24\n    def = false\n  }\n  var dataToString = function (d) {\n    return d.map(function (s, i) {\n      s = s.toString()\n      var s1 = s.replace(re_stripANSI, '')\n      var size = !def ? widths : widths[i]\n      var len = size - s1.length\n\n      if (len < 0) {\n        s = s1.substr(0, size - 1) + '...'\n      } else {\n        s += Array(len).join(' ')\n      }\n      return s\n    }).join('')\n  }\n\n  var rows = []\n\n  data.rows.forEach(function (d) {\n    rows.push(dataToString(d))\n  })\n  this.setContent('{bold}' + dataToString(data.headers) + '{/bold}')\n  this.rows.setItems(rows)\n}\n\n/**\n * Sparkline.\n * @param {Object} options\n * @returns {Sparkline}\n * @constructor\n */\nfunction Sparkline (options) {\n  if (!(this instanceof Sparkline)) {\n    return new Sparkline(options)\n  }\n\n  this.options = util._extend({\n    chars: ['▂', '▃', '▄', '▅', '▆', '▇', '█'],\n    tags: true,\n    padding: {\n      left: 1,\n      top: 1\n    }\n  }, options || {})\n  blessed.Box.call(this, this.options)\n}\nutil.inherits(Sparkline, blessed.Box)\n\n/**\n * Set data.\n * @param {Array} data\n */\nSparkline.prototype.setData = function (data, min, max) {\n  var chars = this.options.chars\n  max = typeof max === 'undefined' ? Math.max.apply(null, data) : max\n  min = typeof min === 'undefined' ? Math.min.apply(null, data) : min\n  var dis = max - min\n  var len = chars.length - 1\n\n  if (dis === 0) {\n    dis = 1\n  }\n\n  var content = data.map(function (n) {\n    var index = Math.round((n - min) / dis * len)\n    return chars[index]\n  }).join('')\n  this.setContent(content)\n}\n\n/**\n * Log.\n * @param {Object} options\n * @returns {Log}\n * @constructor\n */\nfunction Log (options) {\n  if (!(this instanceof Log)) {\n    return new Log(options)\n  }\n\n  this.options = options || {}\n\n  blessed.ScrollableBox.call(this, this.options)\n\n  this.logs = []\n}\nutil.inherits(Log, blessed.ScrollableBox)\n\n/**\n * Log logs.\n * @param {String} str\n */\nLog.prototype.log = function (str, size) {\n  size = size || this.height\n  this.logs.push(str)\n  var len = this.logs.length - size\n  if (len > 0) {\n    this.logs.splice(0, len)\n  }\n  this.setContent(this.logs.join('\\n'))\n  this.setScrollPerc(100)\n}\n\nfunction _reduce (x, y) {\n  return x + y\n}\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/node_modules/pm2-gui/lib/daemon.js":"var chalk = require('chalk')\nvar path = require('path')\nvar fs = require('fs')\nvar async = require('async')\nvar cp = require('child_process')\nvar fork = cp.fork\nvar spawn = cp.spawn\nvar Monitor = require('./monitor')\nvar Log = require('./util/log')\n\nvar processDirname = path.resolve(__dirname, '../')\nvar confFile = './pm2-gui.ini'\nvar cmd = 'start'\n\nif (process.argv.length > 2) {\n  cmd = process.argv[2]\n}\n\nif (process.argv.length > 3) {\n  confFile = process.argv[3]\n}\n\nconfFile = path.resolve(processDirname, confFile)\n\nif (!fs.existsSync(confFile)) {\n  console.error(chalk.bold(confFile), chalk.red('does not exist!'))\n  process.exit(0)\n} else {\n  var monitor = Monitor({\n    confFile: confFile\n  })\n  var daemonize = monitor.options.daemonize && cmd !== 'mon'\n\n  Log(monitor.options.log)\n\n  var pidfile = path.resolve(processDirname, './pm2-gui.pid')\n\n  var Daemon = {\n    restarts: 0,\n    init: function (next) {\n      process.on('SIGTERM', Daemon.stop)\n      process.on('SIGINT', Daemon.stop)\n      process.on('SIGHUP', Daemon.restart)\n      next && next()\n    },\n    start: function (next) {\n      Daemon.worker = Daemon.fork()\n      next && next()\n    },\n    restart: function () {\n      console.info('Restarting...')\n      Daemon.kill()\n      Daemon.start()\n    },\n    stop: function () {\n      console.info('Stopping...')\n      Daemon.kill()\n      daemonize && fs.existsSync(pidfile) && fs.unlinkSync(pidfile)\n      process.exit(0)\n    },\n    kill: function () {\n      if (Daemon.timer) {\n        clearTimeout(Daemon.timer)\n        Daemon.timer = null\n      }\n      if (Daemon.worker) {\n        Daemon.worker.suicide = true\n        Daemon.worker.kill()\n      }\n    },\n    fork: function () {\n      console.info('Forking slave...')\n      Daemon.timer = null\n      var worker = fork(path.resolve(processDirname, 'pm2-gui.js'), [cmd, confFile, '--color'], {\n        silent: daemonize,\n        env: process.env\n      })\n      worker.on('exit', function (code, signal) {\n        if (code !== 0) {\n          if (Daemon.restarts < 10) {\n            Daemon.restarts++\n            setTimeout(function () {\n              Daemon.restarts--\n            }, 20000)\n          } else {\n            console.error(Daemon.restarts + ' restarts in 20 seconds, view the logs to investigate the crash problem.')\n            return process.exit(0)\n          }\n        }\n        if (!worker.suicide && code !== 0) {\n          Daemon.timer = setTimeout(Daemon.fork, 3000)\n        }\n      })\n\n      worker.on('message', function (message) {\n        if (typeof message === 'object' && message.action) {\n          if (message.action === 'restart') {\n            Daemon.restart()\n          }\n        }\n      })\n\n      var logDir = monitor.options.log.dir\n      var stdout = 'pm2-gui.out'\n      var stderr = 'pm2-gui.err'\n\n      if (!logDir) {\n        logDir = './logs'\n      }\n      logDir = path.resolve(processDirname, logDir)\n      if (!fs.existsSync(logDir)) {\n        fs.mkdirSync(logDir)\n      }\n\n      if (daemonize) {\n        stdout = fs.createWriteStream(path.join(logDir, stdout))\n        stderr = fs.createWriteStream(path.join(logDir, stderr))\n        worker.stdout.pipe(stdout)\n        worker.stderr.pipe(stderr)\n\n        fs.writeFile(pidfile, worker.pid)\n      }\n      return worker\n    },\n    daemonize: function () {\n      if (process.env.daemonized) {\n        console.info('Daemonized with pid [' + process.pid + '].')\n        return\n      }\n      console.info('Spawning daemon...')\n      var args = [].concat(process.argv)\n      args.shift()\n      var env = process.env\n      env.daemonized = true\n      var child = spawn(process.execPath, args, {\n        env: env,\n        detached: false,\n        cwd: processDirname,\n        stdio: ['ignore', process.stdout, process.stderr]\n      })\n      child.unref()\n      process.exit()\n    }\n  }\n\n  if (daemonize) {\n    Daemon.daemonize()\n  }\n\n  process.title = 'pm2-gui daemon ' + confFile\n  async.series([\n    Daemon.init,\n    Daemon.start\n  ], function (err) {\n    if (err) {\n      console.error(err.stack)\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/node_modules/pm2-gui/web/public/js/auth.html.js":"var btn, pwd, light, timer;\n\n$(window).ready(function () {\n  light = $('span');\n  pwd = $('input:password');\n  pwd.focus();\n\n  // Login.\n  pwd.keyup(function (e) {\n    if (e.keyCode == 13) {\n      login();\n    }\n  });\n  btn = $('a').click(login);\n\n  drawLogo();\n});\n\n// Login event.\nfunction login() {\n  // Called one time.\n  if (btn.hasClass('active')) {\n    return;\n  }\n  var val = pwd.val().trim();\n  if (!val) {\n    pwd.focus();\n    return;\n  }\n\n  // Post data to server.\n  lightUp();\n  $.ajax({\n    url: 'auth_api?t=' + Math.random(),\n    data: {\n      authorization: val\n    },\n    dataType: 'json',\n    error: function () {\n      info('Can not get response from server, it is an internal error.');\n      lightOff();\n    },\n    success: function (res) {\n      lightOff();\n      if (res.error) {\n        return info(res.error);\n      } else {\n        window.location.href = '/';\n      }\n    }\n  });\n};\n\n// Beginning of AJAX.\nfunction lightUp() {\n  lightOff();\n  btn.addClass('active');\n\n  timer = setInterval(function () {\n    light.toggleClass('active');\n  }, 500);\n}\n\n// Ending of AJAX.\nfunction lightOff() {\n  if (timer) {\n    clearInterval(timer);\n    timer = null;\n  }\n  $('.active').removeClass('active');\n}\n\n// Show tips.\nfunction info(msg) {\n  $.sticky({\n    body: msg,\n    icon: './img/info.png',\n    useAnimateCss: true\n  });\n}\n\nfunction drawLogo() {\n  var w = 80,\n    h = 32;\n\n  var svg = d3.select('#logo')\n    .append('svg')\n    .attr('width', w)\n    .attr('height', h);\n\n  var filter = svg.append('defs')\n    .append('filter')\n    .attr('id', 'dropshadow')\n\n  filter.append('feGaussianBlur')\n    .attr('in', 'SourceAlpha')\n    .attr('stdDeviation', 1)\n    .attr('result', 'blur');\n  filter.append('feOffset')\n    .attr('in', 'blur')\n    .attr('dx', 4)\n    .attr('dy', 4)\n    .attr('result', 'offsetBlur')\n  filter.append('feFlood')\n    .attr('in', 'offsetBlur')\n    .attr('flood-color', '#0a6506')\n    .attr('flood-opacity', '0.9')\n    .attr('result', 'offsetColor');\n  filter.append('feComposite')\n    .attr('in', 'offsetColor')\n    .attr('in2', 'offsetBlur')\n    .attr('operator', 'in')\n    .attr('result', 'offsetBlur');\n\n  var feMerge = filter.append('feMerge');\n\n  feMerge.append('feMergeNode')\n    .attr('in', 'offsetBlur')\n  feMerge.append('feMergeNode')\n    .attr('in', 'SourceGraphic');\n\n  var vis = svg\n    .append('g')\n    .attr('width', w)\n    .attr('height', h);\n\n  vis.append('path')\n    .style('fill', 'none')\n    .style('stroke', '#fff')\n    .style('stroke-width', 2)\n    .attr('d', 'M24,12 T16,8 T4,16 T16,28 T24,20 T18,20 T28,18 T30,16 T44,24 T48,16 T58,8 L58,28 T62,16 T68,16 T72,16 T76,16')\n    .attr('filter', 'url(#dropshadow)');\n}\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/node_modules/pm2-gui/web/public/js/index.html.js":"\"use strict\";\n\nvar sysStat,\n  sockets = {},\n  pageIndex = 1,\n  pageLoaded,\n  procAnimated,\n  procs,\n  prevProcs,\n  tmps = {},\n  eles = {},\n  NSP = {\n    SYS: '/sys',\n    PROC: '/proc',\n    LOG: '/log'\n  },\n  timer,\n  popupShown,\n  popupProc,\n  scrolled;\n\n$(window).ready(function() {\n  if (!Array.isArray(GUI.connections) || GUI.connections.length == 0) {\n    info('No agent is online, can not start it.');\n  } else {\n    GUI.connection = GUI.connections[GUI.connections.length - 1];\n  }\n  prepareDOM();\n  initFullPage();\n  listenSocket();\n  renderFanavi();\n});\n/**\n * Prepare DOM, cache elements, templates...\n */\nfunction prepareDOM() {\n  eles = {\n    fpNav: $('#fp-nav'),\n    procs: $('.procs').eq(0),\n    procsHintContainer: $('.procs-hint-container').eq(0)\n  };\n\n  eles.procsHint = eles.procsHintContainer.find('div').eq(0);\n  eles.procsHintNum = eles.procsHintContainer.find('span').eq(0);\n  eles.procsAction = $('#procs_action');\n\n  // Enable/Disable when mouseenter/mouseleave processes list.\n  eles.procs.hover(function() {\n    !popupShown && setFPEnable(false, true);\n  }, function() {\n    !popupShown && setFPEnable(true, true);\n  });\n\n  tmps = {\n    proc: _.template($('#procTmp').html()),\n    noproc: $('#noProcTmp').html(),\n    popup: _.template($('#popupTmp').html())\n  };\n}\n\n/**\n * Initialize fullPage plugin.\n */\nfunction initFullPage() {\n  $('#fullpage').fullpage({\n    sectionsColor: ['#303552', '#3b4163'],\n    navigation: true,\n    navigationPosition: 'right',\n    navigationTooltips: ['System Stat', 'Processes'],\n    afterLoad: function() {\n      pageLoaded = true;\n    },\n    onLeave: function(index, nextIndex, direction) {\n      pageIndex = nextIndex;\n      pageLoaded = false;\n\n      if (nextIndex == 2) {\n        // Update processes' layout without animation.\n        updateProcsLayout(true);\n\n        if (!procAnimated) {\n          // Animate processes' layout with bounceInDown.\n          procAnimated = true;\n          animate(eles.procs, 'bounceInDown');\n        }\n      }\n    }\n  });\n\n  // Disable fullPage.\n  setFPEnable(false);\n}\n\n/**\n * Set fullPage enable or disable.\n * @param {Boolean} enable\n * @param {Boolean} unscrollable\n */\nfunction setFPEnable(enable, unscrollable) {\n  $.fn.fullpage.setAllowScrolling(enable);\n  if (!unscrollable) {\n    $.fn.fullpage.setKeyboardScrolling(enable);\n    eles.fpNav[enable ? 'fadeIn' : 'fadeOut']();\n  }\n}\n\n/**\n * Connect to socket server.\n */\nfunction connectSocketServer(ns) {\n  var uri = GUI.connection.value;\n  if (GUI.connection.short == 'localhost') {\n    uri = uri.replace(/^http:\\/\\/[^\\?\\/]+/, location.host);\n  }\n  var index = uri.indexOf('?'),\n    query = '';\n  if (index > 0) {\n    query = uri.slice(index);\n    uri = uri.slice(0, index);\n  }\n\n  uri = _.trimRight(uri, '/') + (ns || '') + query;\n\n  var socket = io.connect(uri, {\n    forceNew: true,\n    timeout: 3000\n  });\n  socket.on('error', onError);\n  socket.on('connect_error', onError);\n  return socket;\n}\n\n/**\n * Fires on error.\n * @param  {String} err\n */\nfunction onError(err) {\n  if (err == 'unauthorized') {\n    err = 'There was an error with the authentication: ' + err;\n  } else {\n    err = 'Can not connect to the server due to ' + err;\n  }\n  info(err);\n}\n\n/**\n * Initialize socket.io client and add listeners.\n */\nfunction listenSocket() {\n  sockets._root = connectSocketServer();\n  sockets.sys = connectSocketServer(NSP.SYS);\n  // information from server.\n  sockets.sys.on('info', info);\n  // processes\n  sockets.sys.on('procs', onProcsChange);\n\n  // The first time to request system state.\n  sockets.sys.on('system_stat', onSysStat);\n\n  function onSysStat(data) {\n    // Remove listen immediately.\n    sockets.sys.removeEventListener('system_stat', onSysStat);\n\n    // Store system states.\n    sysStat = data;\n\n    // Render polar chart.\n    polarUsage();\n\n    // Bind system information.\n    var tmp = _.template($('#sysInfoTmp').html());\n    $('.system-info').html(tmp({\n      data: {\n        cpu: sysStat.cpus.length,\n        arch: sysStat.arch,\n        uptime: fromNow(sysStat.uptime),\n        memory: getMem(sysStat.memory.total)\n      }\n    })).css('opacity', 0.01).show().animate({\n      opacity: 1,\n      marginTop: -40\n    });\n\n    // Enable fullPage.\n    setFPEnable(true);\n\n    // Remove loading.\n    $('.spinner').remove();\n  }\n\n  sockets.sys.on('pm2_ver', function(ver) {\n    $('.repo > span').text('PM2 v' + ver);\n  });\n\n  // Show alert when stopping process by pm_id failed.\n  sockets.sys.on('action', function(id, errMsg) {\n    info(errMsg);\n    $('#proc_' + id).find('.proc-ops').find('.load').fadeOut(function() {\n      $(this).prev().fadeIn().end().fadeOut(function() {\n        $(this).remove();\n      });\n    });\n  });\n}\n\n/**\n * Render the fanavi component.\n */\nfunction renderFanavi() {\n  if (GUI.readonly) {\n    return;\n  }\n  var icons = [{\n    icon: 'img/restart.png',\n    title: 'Restart All'\n  }, {\n    icon: 'img/stop.png',\n    title: 'Stop All'\n  }, {\n    icon: 'img/save.png',\n    title: 'Save All'\n  }, {\n    icon: 'img/delete.png',\n    title: 'Delete All'\n  }];\n\n  d3.menu('#procs_action')\n    .option({\n      backgroundColor: '#303552',\n      buttonForegroundColor: '#fff',\n      startAngle: -90,\n      endAngle: 90,\n      innerRadius: 36,\n      shadow: {\n        color: '#4e5786',\n        x: 1,\n        y: 1\n      },\n      iconSize: 24,\n      speed: 500,\n      hideTooltip: true\n    })\n    .load(icons)\n    .on('click', function(index, data) {\n      sockets.sys.emit('action', ['restart', 'stop', 'save', 'delete'][index], 'all');\n    });\n}\n\n/**\n * Reset the status of navigator.\n */\nfunction resetFanavi() {\n  var isVisible = eles.procsAction.is(':visible');\n  if (procs.data.length > 0 && !isVisible) {\n    eles.procsAction.css({\n      opacity: 0.01,\n      display: 'inherit'\n    }).stop().animate({\n      opacity: 1\n    });\n  } else if (procs.data.length == 0 && isVisible) {\n    eles.procsAction.stop().animate({\n      opacity: 0.01\n    }, function() {\n      $(this).css('display', 'none');\n    });\n  }\n}\n\n/**\n * Render polar charset of usage (CPU and memory).\n */\nfunction polarUsage() {\n  if (!sysStat) {\n    return;\n  }\n  var width = 520,\n    height = 520,\n    radius = Math.min(width, height) / 2,\n    spacing = .15;\n\n  // Usage colors - green to red.\n  var color = d3.scale.linear()\n    .range(['hsl(-270,50%,50%)', 'hsl(0,50%,50%)'])\n    .interpolate(function(a, b) {\n      var i = d3.interpolateString(a, b);\n      return function(t) {\n        return d3.hsl(i(t));\n      };\n    });\n\n  // Transform percentage to angle.\n  var arc = d3.svg.arc()\n    .startAngle(0)\n    .endAngle(function(d) {\n      return d.value * 2 * Math.PI;\n    })\n    .innerRadius(function(d) {\n      return d.index * radius;\n    })\n    .outerRadius(function(d) {\n      return (d.index + spacing) * radius;\n    });\n\n  // Initialize polar.\n  $('.polar-usage').find('svg').remove();\n  var svg = d3.select('.polar-usage').style({\n      height: height + 'px',\n      width: width + 'px'\n    }).append('svg')\n    .attr('width', width)\n    .attr('height', height)\n    .append('g')\n    .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');\n\n  // Text of hostname.\n  svg.append('text')\n    .attr('dy', 0)\n    .text(sysStat.hostname);\n\n  // Text of platform and release\n  svg.append('text')\n    .attr('dy', 20)\n    .style('fill', '#ccc')\n    .text(sysStat.platform + ' ' + sysStat.release);\n\n  // Initialize CPU and Memory fields.\n  var field = svg.selectAll('g')\n    .data(fields)\n    .enter().append('g');\n\n  field.append('path');\n  field.append('text');\n\n  // Render it.\n  d3.transition().duration(0).each(refresh);\n\n  // arcTween\n  function arcTween(d) {\n    var i = d3.interpolateNumber(d.previousValue, d.value);\n    return function(t) {\n      d.value = i(t);\n      return arc(d);\n    };\n  }\n\n  // Real-time.\n  function fields() {\n    return [{\n      index: .7,\n      text: 'CPU ' + sysStat.cpu + '%',\n      value: sysStat.cpu / 100\n    }, {\n      index: .4,\n      text: 'MEM ' + sysStat.memory.percentage + '%',\n      value: sysStat.memory.percentage / 100\n    }];\n  }\n\n  // Refresh system states.\n  function refresh() {\n    field = field\n      .each(function(d) {\n        this._value = d.value;\n      })\n      .data(fields)\n      .each(function(d) {\n        d.previousValue = this._value;\n      });\n\n    field.select('path')\n      .transition()\n      .ease('elastic')\n      .attrTween('d', arcTween)\n      .style('fill', function(d) {\n        return color(d.value);\n      });\n\n    field.select('text')\n      .attr('dy', function(d) {\n        return d.value < .5 ? '0' : '10px';\n      })\n      .text(function(d) {\n        return d.text;\n      })\n      .transition()\n      .ease('elastic')\n      .attr('transform', function(d) {\n        return 'rotate(' + 360 * d.value + ') ' +\n          'translate(0,' + -(d.index + spacing / 2) * radius + ') ' +\n          'rotate(' + (d.value < .5 ? -90 : 90) + ')'\n      });\n  }\n\n  // When receiving data from server, refresh polar.\n  sockets.sys.on('system_stat', function(data) {\n    if (pageIndex != 1) {\n      return;\n    }\n    var changed = sysStat.cpu != data.cpu || sysStat.memory.percentage != data.memory.percentage;\n    sysStat = data;\n\n    changed && refresh();\n  });\n\n  addChooser({\n    width: width,\n    height: height,\n    radius: radius\n  });\n}\n\n/**\n * Add server chooser to the UI.\n */\nfunction addChooser(options) {\n  if (addChooser._added == true || !Array.isArray(GUI.connections) || GUI.connections.length == 1) {\n    return;\n  }\n  addChooser._added = true;\n  var width = 100,\n    height = 30,\n    style = {\n      width: 100,\n      height: height,\n      left: (options.width - width) / 2,\n      top: (options.height - height) / 2 + 50\n    };\n\n  var chooser = $('<div>', {\n    'class': 'chooser dropdown',\n    css: style\n  });\n\n  var conns = _.clone(GUI.connections);\n  if (conns[conns.length - 1].short == 'localhost') {\n    conns.splice(conns.length - 1, 0, '-');\n  }\n  var html = '<button id=\"dropdownChooser\" class=\"btn btn-primary btn-sm dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"true\"><i class=\"glyphicon glyphicon-random\"></i> CHANGE <span class=\"caret\"></span></button>';\n  html += '<ul class=\"dropdown-menu\" aria-labelledby=\"dropdownChooser\">';\n  conns.forEach(function(conn) {\n    if (conn == '-') {\n      html += '<li role = \"separator\" class=\"divider\"></li>';\n    } else {\n      html += '<li ' + (GUI.connection.value == conn.value ? 'class=\"active\"' : '') + '><a href=\"javascript:void(0);\" data-value=\"' + conn.value + '\" data-short=\"' + conn.short + '\">' + conn.name + '</a></li>';\n    }\n  });\n  html += '</ul>';\n  chooser.html(html);\n  chooser.on('click', 'a', function() {\n    var ele = $(this),\n      val = ele.data('value');\n    if (val && val != GUI.connection.value) {\n      GUI.connection = {\n        name: ele.text(),\n        value: val,\n        short: ele.data('short')\n      };\n      chooser.find('li.active').removeClass('active');\n      ele.parent().addClass('active');\n      changeConnection();\n    }\n  }).on('show.bs.dropdown', function() {\n    setFPEnable(false, false);\n  }).on('hide.bs.dropdown', function() {\n    setFPEnable(true, false);\n  });\n  chooser.appendTo('.polar-usage');\n}\n\n/**\n * Change the connection.\n * @param  {[type]} connection [description]\n * @return {[type]}            [description]\n */\nfunction changeConnection(connection) {\n  for (var ns in sockets) {\n    sockets[ns].disconnect();\n    sockets[ns].io.close();\n    delete sockets[ns];\n  }\n\n  listenSocket();\n}\n\n/**\n * Be triggered after processes have been changed.\n * @param _procs\n */\nfunction onProcsChange(_procs) {\n  // Stora processes.\n  procs = {\n    data: _procs.filter(function(p) {\n      return !!p;\n    }),\n    tick: Date.now()\n  };\n\n  // Compare ticks to make sure there has any change.\n  var isProcsChanged = eles.procsHint.data('tick') != procs.tick;\n\n  if (!isProcsChanged) {\n    return;\n  }\n\n  if (pageIndex == 1) {\n    // Update processes count only on fullPage 1 (with animation).\n    updateProcsCount(true);\n  } else if (pageIndex == 2) {\n    // Update processes count on fullPage 1 (without animation).\n    updateProcsCount();\n    // Update processes' layout on fullPage 2.\n    updateProcsLayout();\n  }\n\n  resetFanavi();\n}\n\n/**\n * Update processes count.\n * @param {Boolean} withAnimation\n */\nfunction updateProcsCount(withAnimation) {\n  var len = procs.data.length;\n  // If there has no change, return it.\n  if (eles.procsHintContainer.data('count') == len) {\n    return;\n  }\n  // Store count to element.\n  eles.procsHintContainer.data('count', len).removeClass('hide');\n  // Reset count.\n  eles.procsHintNum.text(len);\n  // Shake it if necessary.\n  withAnimation && animate(eles.procsHint, 'shake');\n}\n\n/**\n * Update the processes' layout.\n * @param {Boolean} noAnimation\n * @returns {*}\n */\nfunction updateProcsLayout(noAnimation) {\n  // If has no change, return it.\n  if (!procs || eles.procs.data('tick') == procs.tick) {\n    return cloneProcs();\n  }\n\n  // Store tick.\n  eles.procs.data('tick', procs.tick);\n\n  // Has process or not.\n  var noprocRendered = eles.procs.data('empty'),\n    isEmpty = eles.procs.is(':empty');\n\n  // If there has no process.\n  if (procs.data.length == 0) {\n    // And the `empty tip` is rendered, return it.\n    if (noprocRendered) {\n      return cloneProcs();\n    }\n    // It's an empty list.\n    eles.procs.data('empty', true);\n\n    // destroy slimScroll if necessary.\n    destroySlimScroll();\n\n    // Render `empty tip`.\n    $(tmps.noproc).prependTo(eles.procs);\n\n    // Remove previous processes list.\n    if (!isEmpty) {\n      !noAnimation && animate(eles.procs, 'flip');\n      eles.procs.find('.proc,.proc-div').not('.proc-empty').remove();\n    }\n    return cloneProcs();\n  }\n\n  // If there have processes and the `empty tip` is rendered.\n  if (noprocRendered) {\n    // Remove empty data.\n    eles.procs.removeData('empty');\n    // Create processes' layout.\n    createProcs(procs.data, noprocRendered, noAnimation);\n    return cloneProcs();\n  }\n\n  // If there has no process and never render `empty tip`.\n  if (isEmpty) {\n    // Create processes' layout.\n    createProcs(procs.data, noprocRendered, noAnimation);\n    return cloneProcs();\n  }\n\n  // Read existing processes' Uids.\n  var rps = [];\n  eles.procs.find('div.proc').each(function() {\n    rps.push(parseInt(this.id.substr(5)));\n  });\n  // Processes that waiting to be created.\n  var cps = procs.data;\n  // Processes that should be deleted.\n  var dps = _.difference(rps, cps.map(function(p) {\n    return p.pm_id;\n  }));\n  // Processes that should be updated.\n  var ups = [];\n\n  // Remove the processes to be deleted.\n  rps = _.difference(rps, dps);\n\n  if (rps.length > 0) {\n    // Remove existing.\n    cps = cps.filter(function(p) {\n      return !~rps.indexOf(p.pm_id);\n    });\n\n    // Compare with previous processes to grep `ups`.\n    if (prevProcs) {\n      rps.forEach(function(pm_id) {\n        var proc1 = _.find(prevProcs.data, function(p) {\n            return p.pm_id == pm_id;\n          }),\n          proc2 = _.find(procs.data, function(p) {\n            return p.pm_id == pm_id;\n          });\n\n        if (proc1 && proc2 &&\n          (proc1.pm2_env.status != proc2.pm2_env.status ||\n            proc1.pm2_env.pm_uptime != proc2.pm2_env.pm_uptime ||\n            proc1.pm2_env.restart_time != proc2.pm2_env.restart_time)) {\n          ups.push(proc2);\n        }\n      });\n    }\n  }\n\n  var animated = false;\n  // Create.\n  if (cps.length > 0) {\n    animated = true;\n    createProcs(cps, noprocRendered, noAnimation);\n  }\n  // Delete\n  if (dps.length > 0) {\n    removeProcs(dps, animated || noAnimation);\n    animated = true;\n  }\n  // Update\n  if (ups.length > 0) {\n    updateProcs(ups, animated || noAnimation);\n  }\n  cloneProcs();\n}\n\n/**\n * Create processes' layout.\n * @param {Array} _procs\n * @param {Boolean} noproc `empty tip` is rendered before.\n * @param {Boolean} noAnimation\n */\nfunction createProcs(_procs, noproc, noAnimation) {\n  var html = '';\n  _.sortBy(_procs, 'pm_id').forEach(function(p, i) {\n    html += tmps.proc({\n      proc: p,\n      noDiv: false,\n      index: i\n    });\n  });\n  $(html).appendTo(eles.procs)\n    // Attach events of process.\n  attachProcEvents();\n\n  // Flip in if necessary.\n  !noAnimation && flipProcs();\n\n  // Remove `empty tip` if necessary.\n  noproc && eles.procs.find('.proc-empty').remove();\n\n  // slimScroll if processes length is greater than 10.\n  if (eles.procs.find('div.proc').length > 10) {\n    if (eles.procs.data('slimScroll')) {\n      return;\n    }\n    eles.procs.data('slimScroll', true);\n    eles.procs.slimScroll({\n      height: '600px',\n      width: '720px',\n      color: '#fff',\n      opacity: 0.8,\n      railVisible: true,\n      railColor: '#fff'\n    });\n  } else {\n    destroySlimScroll();\n  }\n}\n\n/**\n * Update processes' layout.\n * @param {Array} _procs\n * @param {Boolean} noAnimation\n */\nfunction updateProcs(_procs, noAnimation) {\n  // Find elements and replace them new ones.\n  eles.procs.find(_procs.map(function(p) {\n    return '#proc_' + p.pm_id;\n  }).join(',')).each(function(i) {\n    var ele = $(this),\n      placement = ele.find('.proc-ops i').eq(0).data('placement'),\n      _id = parseInt(ele.attr('id').substr(5)),\n      proc = _.find(_procs, function(p) {\n        return p.pm_id == _id;\n      });\n\n    // HTML\n    var procHTML = tmps.proc({\n      proc: proc,\n      noDiv: true,\n      index: placement !== 'top' ? 0 : 1\n    });\n    var procEle = $(procHTML);\n    procEle.data({\n      'event-avgrund': null,\n      'event-click': null\n    });\n\n    var ele = $(this);\n    // Animate it or not.\n    if (!noAnimation) {\n      animate(ele, 'flipOutX', function() {\n        ele.replaceWith(procEle);\n        attachProcEvents();\n        animate(procEle, 'flipInX', startTimer);\n      });\n    } else {\n      ele.replaceWith(procEle);\n      attachProcEvents();\n    }\n  });\n}\n\n/**\n * Remove processes from layout.\n * @param {Array} pm_ids pm_ids of processes.\n * @param {Boolean} noAnimation\n */\nfunction removeProcs(pm_ids, noAnimation) {\n  // Find elements and remove them directly.\n  eles.procs.find(pm_ids.map(function(id) {\n    return '#proc_' + id;\n  }).join(',')).each(function() {\n    var ele = $(this);\n    ele.next().remove();\n    ele.remove();\n  });\n\n  // Flip it if necessary.\n  !noAnimation && flipProcs();\n\n  // Destroy slimScroll if necessary.\n  if (eles.procs.find('div.proc').length <= 10) {\n    destroySlimScroll();\n  }\n}\n\n/**\n * Clone processes and count uptime from now.\n */\nfunction cloneProcs() {\n  // Clone processes.\n  prevProcs = _.clone(procs);\n\n  // Timer of uptime.\n  startTimer();\n}\n\n/**\n * Timer of uptime.\n */\nfunction startTimer() {\n  timer && clearTimeout(timer);\n  updateUptime();\n}\n\n/**\n * Update the uptimes of processes.\n */\nfunction updateUptime() {\n  var spans = eles.procs.find('span[data-ctime][data-running=YES]');\n  if (spans.length == 0) {\n    return;\n  }\n  var now = Date.now();\n  spans.each(function() {\n    var ele = $(this);\n    ele.text(fromNow(Math.ceil((now - ele.data('ctime')) / 1000), true));\n  });\n\n  // Only do this job on fullPage 2.\n  (pageIndex == 2) && (timer = setTimeout(updateUptime, 1000));\n}\n\n/**\n * Flip processes' layout.\n */\nfunction flipProcs() {\n  var p = eles.procs.parent();\n  animate(p.hasClass('slimScrollDiv') ? p : eles.procs, 'flip');\n}\n\n/**\n * Destroy slimScroll of processes' layout.\n */\nfunction destroySlimScroll() {\n  if (!eles.procs.data('slimScroll')) {\n    return;\n  }\n  eles.procs.slimScroll({\n    destroy: true\n  });\n  eles.procs.data('slimScroll', false).css('height', 'auto');\n}\n\n/**\n * Attach events to process layout.\n */\nfunction attachProcEvents() {\n  bindPopup();\n  procEvents();\n}\n\n/**\n * Bind process events.\n */\nfunction procEvents() {\n  eles.procs.find('.proc-ops i').each(function() {\n    var ele = $(this);\n    if (ele.data('event-click') == 'BOUND') {\n      return;\n    }\n    ele.data('event-click', 'BOUND').click(function() {\n      var ele = $(this),\n        method = (ele.data('original-title') || ele.attr('title')).toLowerCase(),\n        pm_id = parseInt(ele.closest('.proc').attr('id').substr(5));\n\n      var ops = ele.closest('.proc-ops');\n      $('<div class=\"load\"></div>').css({\n        opacity: 0.01\n      }).appendTo(ops);\n\n      ops.find('ul').fadeOut().next().animate({\n        opacity: 1\n      });\n\n      sockets.sys.emit('action', method, pm_id);\n    });\n  });\n  eles.procs.find('[data-toggle=\"tooltip\"]').tooltip({\n    container: 'body'\n  });\n}\n\n/**\n * Popup dialog to display full information of processes.\n * @param {jQuery} o\n */\nfunction bindPopup(o) {\n  eles.procs.find('.proc-name').each(function() {\n    var ele = $(this);\n    if (ele.data('event-avgrund') == 'BOUND') {\n      return;\n    }\n    ele.data('event-avgrund', 'BOUND').avgrund({\n      width: 640,\n      height: 350,\n      showClose: true,\n      holderClass: 'proc-popup',\n      showCloseText: 'CLOSE',\n      onBlurContainer: '.section',\n      onLoad: function(ele) {\n        if (popupShown) {\n          return;\n        }\n        popupShown = true;\n        setFPEnable(false, false);\n        showPopupTab(getProcByEle(ele));\n      },\n      onUnload: function(ele) {\n        if (!popupShown) {\n          return;\n        }\n        scrolled = false;\n        popupShown = false;\n        setFPEnable(true, false);\n        destroyTail();\n        destroyMonitor();\n        popupProc = null;\n      },\n      template: '<div id=\"popup\"><div class=\"load\"></div></div>'\n    });\n  });\n}\n\n/**\n * Reset tabcontent of popup.\n * @param {Object} proc\n * @returns {*}\n */\nfunction showPopupTab(proc, delayed) {\n  if (!proc) {\n    return info('Process does not exist, try to refresh current page manually (F5 or COMMAND+R)');\n  }\n  // Do this after popup is shown.\n  if (!delayed) {\n    return setTimeout(showPopupTab, 800, proc, true);\n  }\n\n  // Resort keys.\n  var clonedProc = {};\n  _.sortBy(Object.keys(proc)).forEach(function(key) {\n    // Omit memory, just keep the original data.\n    if (key == 'monit') {\n      var monit = proc[key];\n      monit.memory = getMem(monit.memory);\n      return clonedProc[key] = monit;\n    }\n    clonedProc[key] = proc[key];\n  });\n\n  // Reset content HTML.\n  var popup = $('#popup').html(tmps.popup({\n    info: highlight(clonedProc)\n  }));\n  // Find tabcontent.\n  var tabContent = popup.find('.tab-content').eq(0);\n  // Bind slimScroll.\n  tabContent.slimScroll({\n    height: '300px',\n    color: '#000',\n    opacity: 0.8,\n    railVisible: true,\n    railColor: '#f0f0f0'\n  });\n\n  // Bing tab change event.\n  popup.find('li').click(function() {\n    var ele = $(this);\n    if (ele.hasClass('active')) {\n      return;\n    }\n\n    // Scroll to y: 0\n    tabContent.slimScroll({\n      scrollTo: 0\n    });\n\n    var tab = $(this).text().trim();\n\n    if (tab != 'Log') {\n      destroyTail();\n      $('#log').html('<div class=\"load\"></div>');\n      scrolled = false;\n      popupProc = null;\n    }\n\n    if (tab != 'Monitor') {\n      destroyMonitor();\n      $('#monitor').html('<div class=\"load\"></div>');\n      popupProc = null;\n    }\n\n    // Tail logs.\n    if (tab == 'Log') {\n      popupProc = proc;\n      return tailLogs();\n    }\n    if (tab == 'Monitor') {\n      popupProc = proc;\n      return monitorProc();\n    }\n  })\n}\n\n/**\n * Tail log of process\n * @returns {*}\n */\nfunction tailLogs() {\n  if (!popupProc) {\n    $('#log').html('<span style=\"color:#ff0000\">Process does not exist.</span>')\n    return;\n  }\n  if (!sockets.log) {\n    sockets.log = connectSocketServer(NSP.LOG);\n    sockets.log.on('log', appendLogs);\n    sockets.log.on('connect', function() {\n      sockets.log.emit('tail', popupProc.pm_id);\n    });\n  } else {\n    sockets.log.connect();\n  }\n}\n\n/**\n * Append logs to DOM.\n * @param {Object} log\n */\nfunction appendLogs(log) {\n  // Check process and pm_id should be equalled.\n  if (!popupProc || popupProc.pm_id != log.pm_id) {\n    return;\n  }\n\n  // Remove `loading` status.\n  $('#log>.load').remove();\n\n  var lo = $('#log'),\n    loDom = lo.get(0);\n\n  var offset = loDom.scrollHeight - 300,\n    poffset = lo.parent().scrollTop() || 0,\n    scrollable = false;\n\n  // Scroll down if necessary.\n  if (!scrolled || poffset >= offset - 30) {\n    !scrolled && (scrolled = poffset < offset - 30);\n    scrollable = true;\n  }\n  $(log.msg).appendTo(lo);\n\n  if (scrollable) {\n    lo.parent().slimScroll({\n      scrollTo: loDom.scrollHeight - 300\n    });\n  }\n}\n\n/**\n * Destroy tail socket.\n */\nfunction destroyTail() {\n  if (!sockets.log) {\n    return;\n  }\n  sockets.log.disconnect();\n}\n\n/**\n * Monitor the memory && CPU usage of process.\n */\nfunction monitorProc() {\n  if (!popupProc || popupProc.pid == 0) {\n    $('#monitor').html('<span style=\"color:#ff0000\">Process does not exist or is not running.</span>')\n    return;\n  }\n  if (!sockets.proc) {\n    sockets.proc = connectSocketServer(NSP.PROC);\n    sockets.proc.on('proc', appendData);\n    sockets.proc.on('connect', function() {\n      sockets.proc.emit('proc', popupProc.pid);\n    });\n  } else {\n    sockets.proc.connect();\n  }\n}\n\n/**\n * Append data to lineChart.\n * @param proc\n */\nfunction appendData(proc) {\n  if (!popupProc || popupProc.pid != proc.pid) {\n    return;\n  }\n  var loadEl = $('#monitor>.load');\n  if (lineChart.data.length == 0) {\n    var now = proc.time || Date.now(),\n      len = lineChart.settings.queueLength;\n\n    lineChart.data = d3.range(len).map(function(n) {\n      return {\n        time: now - (len - n) * 3000,\n        usage: {\n          cpu: 0,\n          memory: 0\n        }\n      };\n    });\n  }\n  // handle error\n  if (proc.msg) {\n    delete proc.msg;\n    proc.time = Date.now();\n    proc.usage = {\n      cpu: 0,\n      memory: 0\n    };\n  }\n  lineChart.data.push(proc);\n  if (loadEl.length > 0) {\n    loadEl.remove();\n    lineChart.next();\n  }\n}\n\n/**\n * Destroy monitor socket.\n */\nfunction destroyMonitor() {\n  if (!sockets.proc) {\n    return;\n  }\n  sockets.proc.disconnect();\n  lineChart.destroy();\n}\n\n/**\n * Get process by Uid span element.\n * @param {jQuery} ele\n * @returns {*}\n */\nfunction getProcByEle(ele) {\n  var id = parseInt(ele.data('pmid'));\n  return _.find(procs.data, function(p) {\n    return p.pm_id == id;\n  });\n}\n\n/**\n * Animate element with animation from animate.css\n * @param {jQuery} o element\n * @param {String} a animation name\n * @param {Function} cb callback\n */\nfunction animate(o, a, cb) {\n  a += ' animated';\n  o.removeClass(a).addClass(a).one('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', function() {\n    var ele = $(this);\n    ele.removeClass(a)\n    cb && cb.call(ele);\n  });\n}\n\n/**\n * Show sticky information\n * @param {String} msg\n */\nfunction info(msg) {\n  if (msg instanceof Error) {\n    msg = msg.message;\n  }\n  $.sticky({\n    body: msg,\n    icon: './img/info.png',\n    useAnimateCss: true\n  });\n}\n\n/**\n * Wrap memory.\n * @param {Float} mem\n * @returns {string}\n */\nfunction getMem(mem) {\n  if (typeof mem == 'string') {\n    return mem;\n  }\n\n  if (mem < 1024) {\n    return mem + 'B';\n  }\n  if (mem < 1048576) {\n    return Math.round(mem / 1024) + 'K';\n  }\n  if (mem < 1073741824) {\n    return Math.round(mem / 1048576) + 'M';\n  }\n  return Math.round(mem / 1073741824) + 'G';\n}\n\n/**\n * Wrap tick from now.\n * @param {Float} tick\n * @param {Boolean} tiny show all of it.\n * @returns {string}\n */\nfunction fromNow(tick, tiny) {\n  if (tick < 60) {\n    return tick + 's';\n  }\n  var s = tick % 60 + 's';\n  if (tick < 3600) {\n    return parseInt(tick / 60) + 'm ' + s;\n  }\n  var m = parseInt((tick % 3600) / 60) + 'm ';\n  if (tick < 86400) {\n    return parseInt(tick / 3600) + 'h ' + m + (!tiny ? '' : s);\n  }\n  var h = parseInt((tick % 86400) / 3600) + 'h ';\n  return parseInt(tick / 86400) + 'd ' + h + (!tiny ? '' : m + s);\n}\n\n/**\n * Hightlight JSON\n * @param {JSON} data\n * @param {Int} indent\n * @returns {string}\n */\nfunction highlight(data, indent) {\n  indent = indent || 2;\n\n  data = JSON.stringify(typeof data != 'string' ? data : JSON.parse(data), undefined, indent);\n\n  [\n    [/&/g, '&amp;'],\n    [/</g, '&lt;'],\n    [/>/g, '&gt;']\n  ].forEach(function(rep) {\n    data = String.prototype.replace.apply(data, rep);\n  });\n\n  return data.replace(/(\"(\\\\u[a-zA-Z0-9]{4}|\\\\[^u]|[^\\\\\"])*\"(\\s*:)?|\\b(true|false|null)\\b|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)/g, function(m) {\n    var color = '1e297e';\n    if (/^\"/.test(m)) {\n      color = ['440a4d', '0d660a'][/:$/.test(m) ? 0 : 1];\n    } else if (/true|false/.test(m)) {\n      color = '1e297e';\n    } else if (/null|undefined/.test(m)) {\n      color = '14193c';\n    }\n    return '<span style=\"color: #' + color + '\">' + m + '</span>';\n  }).replace(/\\n/, '<br />');\n};\n\n/**\n * Line chart represents memory / CPU usage.\n */\nvar lineChart = {\n  settings: {\n    id: '#monitor',\n    width: 580,\n    height: 270,\n    ticks: 5,\n    tension: 0.8,\n    padding: 10,\n    queueLength: 20,\n    transitionDelay: 3000,\n    fancyDelay: 1000,\n    tickFormat: '%H:%M:%S',\n    series: ['cpu', 'memory'],\n    colors: {\n      line: {\n        cpu: 'rgba(0, 200, 0, 1)',\n        memory: 'rgba(200, 200, 0, 1)'\n      },\n      dot: '#ff5400'\n    }\n  },\n  data: [],\n  eles: {},\n  destroy: function() {\n    this.eles.path && this.eles.path.interrupt().transition();\n    this.eles.xAxis && this.eles.xAxis.interrupt().transition();\n    d3.timer.flush();\n    this.data = [];\n    this.eles = {};\n  },\n  next: function(forceQuit) {\n    var ng = !this.eles.svg;\n    if (ng && forceQuit) {\n      return;\n    }\n\n    if (ng) {\n      this._graph();\n    }\n    var st = this.settings;\n\n    if (this.data.length < st.queueLength) {\n      return;\n    }\n\n    this.eles.path.attr('transform', 'translate(0, ' + st.padding + ')');\n    this.eles.xAxis.call(this.eles.x.axis);\n\n    this.eles.x.domain([this.data[1].time, this.data[st.queueLength - 1].time]);\n\n    st.series.forEach(function(key) {\n      lineChart.eles[key + 'LineEl']\n        .attr('d', lineChart.eles[key + 'Line'])\n        .attr('transform', null);\n    });\n\n    if (ng) {\n      return setTimeout(function(ctx) {\n        ctx.next(true);\n      }, 10, this);\n    }\n\n    this.eles.path\n      .transition()\n      .duration(st.transitionDelay)\n      .ease('linear')\n      .attr('transform', 'translate(' + this.eles.x(this.data[0].time) + ', ' + st.padding + ')')\n      .each('end', function() {\n        lineChart.next(true);\n      });\n\n    this.eles.xAxis.transition()\n      .duration(st.transitionDelay)\n      .ease('basic')\n      .call(this.eles.x.axis);\n\n    this.data.shift();\n  },\n  _graph: function() {\n    var st = this.settings;\n    st.gWidth = st.width;\n    st.gHeight = st.height - 50;\n\n    var series = '<ul>';\n    st.series.forEach(function(key) {\n      series += '<li style=\"color:' + st.colors.line[key] + '\">' + key + '</li>';\n    });\n    series += '</ul>';\n\n    $(series).appendTo(st.id);\n\n    this.eles.x = d3.time\n      .scale()\n      .range([0, st.gWidth]);\n\n    this.eles.x.axis = d3.svg.axis()\n      .scale(this.eles.x)\n      .tickFormat(d3.time.format(st.tickFormat))\n      .ticks(st.ticks)\n      .orient('bottom');\n\n    this.eles.y = d3.scale\n      .linear()\n      .domain([0, 100])\n      .range([st.gHeight, 0])\n      .clamp(true);\n\n    this.eles.y.axis = d3.svg\n      .axis()\n      .scale(this.eles.y)\n      .orient('right')\n      .ticks(st.ticks);\n\n    this.eles.svg = d3\n      .select(lineChart.settings.id)\n      .append('svg')\n      .attr('width', st.width)\n      .attr('height', st.height);\n\n    this.eles.svg.append('defs').append('clipPath')\n      .attr('id', 'clip')\n      .append('rect')\n      .attr('width', st.gWidth)\n      .attr('height', st.height);\n\n    this.eles.g = this.eles.svg\n      .append('g')\n      .attr('clip-path', 'url(#clip)')\n      .selectAll('g')\n      .data([this.data])\n      .enter()\n      .append('g')\n      .attr('transform', 'translate(0, 0)');\n\n    this.eles.path = this.eles.g.append('g')\n      .attr('transform', 'translate(0, ' + st.padding + ')');\n\n    st.series.forEach(function(key) {\n      lineChart.eles[key + 'Line'] = d3.svg\n        .line()\n        .interpolate('cardinal')\n        .tension(st.tension)\n        .x(function(d) {\n          return lineChart.eles.x(d.time || Date.now());\n        })\n        .y(function(d) {\n          return lineChart.eles.y(!d.usage ? 0 : d.usage[key]);\n        });\n\n      lineChart.eles[key + 'LineEl'] = lineChart.eles.path.append('path')\n        .attr('class', 'line')\n        .style('stroke', st.colors.line[key])\n        .attr('d', lineChart.eles[key + 'Line']);\n    });\n\n    this.eles.g.append('g')\n      .attr('class', 'y axis')\n      .attr('transform', 'translate(1, ' + st.padding + ')')\n      .call(this.eles.y.axis);\n\n    this.eles.xAxis = this.eles.g.append('g')\n      .attr('class', 'x axis')\n      .attr('transform', 'translate(0,' + (st.gHeight + st.padding) + ')')\n      .call(this.eles.x.axis);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-pm2-gui/node_modules/pm2-gui/web/public/js/socket.io.js":"!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.io=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n\nmodule.exports = _dereq_('./lib/');\n\n},{\"./lib/\":2}],2:[function(_dereq_,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar url = _dereq_('./url');\nvar parser = _dereq_('socket.io-parser');\nvar Manager = _dereq_('./manager');\nvar debug = _dereq_('debug')('socket.io-client');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = lookup;\n\n/**\n * Managers cache.\n */\n\nvar cache = exports.managers = {};\n\n/**\n * Looks up an existing `Manager` for multiplexing.\n * If the user summons:\n *\n *   `io('http://localhost/a');`\n *   `io('http://localhost/b');`\n *\n * We reuse the existing instance based on same scheme/port/host,\n * and we initialize sockets for each namespace.\n *\n * @api public\n */\n\nfunction lookup(uri, opts) {\n  if (typeof uri == 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var io;\n\n  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n    io = cache[id];\n  }\n\n  return io.socket(parsed.path);\n}\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = parser.protocol;\n\n/**\n * `connect`.\n *\n * @param {String} uri\n * @api public\n */\n\nexports.connect = lookup;\n\n/**\n * Expose constructors for standalone build.\n *\n * @api public\n */\n\nexports.Manager = _dereq_('./manager');\nexports.Socket = _dereq_('./socket');\n\n},{\"./manager\":3,\"./socket\":5,\"./url\":6,\"debug\":10,\"socket.io-parser\":44}],3:[function(_dereq_,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar url = _dereq_('./url');\nvar eio = _dereq_('engine.io-client');\nvar Socket = _dereq_('./socket');\nvar Emitter = _dereq_('component-emitter');\nvar parser = _dereq_('socket.io-parser');\nvar on = _dereq_('./on');\nvar bind = _dereq_('component-bind');\nvar object = _dereq_('object-component');\nvar debug = _dereq_('debug')('socket.io-client:manager');\nvar indexOf = _dereq_('indexof');\nvar Backoff = _dereq_('backo2');\n\n/**\n * Module exports\n */\n\nmodule.exports = Manager;\n\n/**\n * `Manager` constructor.\n *\n * @param {String} engine instance or engine uri/opts\n * @param {Object} options\n * @api public\n */\n\nfunction Manager(uri, opts){\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\n  if (uri && ('object' == typeof uri)) {\n    opts = uri;\n    uri = undefined;\n  }\n  opts = opts || {};\n\n  opts.path = opts.path || '/socket.io';\n  this.nsps = {};\n  this.subs = [];\n  this.opts = opts;\n  this.reconnection(opts.reconnection !== false);\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n  this.randomizationFactor(opts.randomizationFactor || 0.5);\n  this.backoff = new Backoff({\n    min: this.reconnectionDelay(),\n    max: this.reconnectionDelayMax(),\n    jitter: this.randomizationFactor()\n  });\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n  this.readyState = 'closed';\n  this.uri = uri;\n  this.connected = [];\n  this.encoding = false;\n  this.packetBuffer = [];\n  this.encoder = new parser.Encoder();\n  this.decoder = new parser.Decoder();\n  this.autoConnect = opts.autoConnect !== false;\n  if (this.autoConnect) this.open();\n}\n\n/**\n * Propagate given event to sockets and emit on `this`\n *\n * @api private\n */\n\nManager.prototype.emitAll = function() {\n  this.emit.apply(this, arguments);\n  for (var nsp in this.nsps) {\n    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n  }\n};\n\n/**\n * Update `socket.id` of all sockets\n *\n * @api private\n */\n\nManager.prototype.updateSocketIds = function(){\n  for (var nsp in this.nsps) {\n    this.nsps[nsp].id = this.engine.id;\n  }\n};\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Manager.prototype);\n\n/**\n * Sets the `reconnection` config.\n *\n * @param {Boolean} true/false if it should automatically reconnect\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnection = function(v){\n  if (!arguments.length) return this._reconnection;\n  this._reconnection = !!v;\n  return this;\n};\n\n/**\n * Sets the reconnection attempts config.\n *\n * @param {Number} max reconnection attempts before giving up\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionAttempts = function(v){\n  if (!arguments.length) return this._reconnectionAttempts;\n  this._reconnectionAttempts = v;\n  return this;\n};\n\n/**\n * Sets the delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelay = function(v){\n  if (!arguments.length) return this._reconnectionDelay;\n  this._reconnectionDelay = v;\n  this.backoff && this.backoff.setMin(v);\n  return this;\n};\n\nManager.prototype.randomizationFactor = function(v){\n  if (!arguments.length) return this._randomizationFactor;\n  this._randomizationFactor = v;\n  this.backoff && this.backoff.setJitter(v);\n  return this;\n};\n\n/**\n * Sets the maximum delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelayMax = function(v){\n  if (!arguments.length) return this._reconnectionDelayMax;\n  this._reconnectionDelayMax = v;\n  this.backoff && this.backoff.setMax(v);\n  return this;\n};\n\n/**\n * Sets the connection timeout. `false` to disable\n *\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.timeout = function(v){\n  if (!arguments.length) return this._timeout;\n  this._timeout = v;\n  return this;\n};\n\n/**\n * Starts trying to reconnect if reconnection is enabled and we have not\n * started reconnecting yet\n *\n * @api private\n */\n\nManager.prototype.maybeReconnectOnOpen = function() {\n  // Only try to reconnect if it's the first time we're connecting\n  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n    // keeps reconnection from firing twice for the same reconnection loop\n    this.reconnect();\n  }\n};\n\n\n/**\n * Sets the current transport `socket`.\n *\n * @param {Function} optional, callback\n * @return {Manager} self\n * @api public\n */\n\nManager.prototype.open =\nManager.prototype.connect = function(fn){\n  debug('readyState %s', this.readyState);\n  if (~this.readyState.indexOf('open')) return this;\n\n  debug('opening %s', this.uri);\n  this.engine = eio(this.uri, this.opts);\n  var socket = this.engine;\n  var self = this;\n  this.readyState = 'opening';\n  this.skipReconnect = false;\n\n  // emit `open`\n  var openSub = on(socket, 'open', function() {\n    self.onopen();\n    fn && fn();\n  });\n\n  // emit `connect_error`\n  var errorSub = on(socket, 'error', function(data){\n    debug('connect_error');\n    self.cleanup();\n    self.readyState = 'closed';\n    self.emitAll('connect_error', data);\n    if (fn) {\n      var err = new Error('Connection error');\n      err.data = data;\n      fn(err);\n    } else {\n      // Only do this if there is no fn to handle the error\n      self.maybeReconnectOnOpen();\n    }\n  });\n\n  // emit `connect_timeout`\n  if (false !== this._timeout) {\n    var timeout = this._timeout;\n    debug('connect attempt will timeout after %d', timeout);\n\n    // set timer\n    var timer = setTimeout(function(){\n      debug('connect attempt timed out after %d', timeout);\n      openSub.destroy();\n      socket.close();\n      socket.emit('error', 'timeout');\n      self.emitAll('connect_timeout', timeout);\n    }, timeout);\n\n    this.subs.push({\n      destroy: function(){\n        clearTimeout(timer);\n      }\n    });\n  }\n\n  this.subs.push(openSub);\n  this.subs.push(errorSub);\n\n  return this;\n};\n\n/**\n * Called upon transport open.\n *\n * @api private\n */\n\nManager.prototype.onopen = function(){\n  debug('open');\n\n  // clear old subs\n  this.cleanup();\n\n  // mark as open\n  this.readyState = 'open';\n  this.emit('open');\n\n  // add new subs\n  var socket = this.engine;\n  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n};\n\n/**\n * Called with data.\n *\n * @api private\n */\n\nManager.prototype.ondata = function(data){\n  this.decoder.add(data);\n};\n\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\nManager.prototype.ondecoded = function(packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon socket error.\n *\n * @api private\n */\n\nManager.prototype.onerror = function(err){\n  debug('error', err);\n  this.emitAll('error', err);\n};\n\n/**\n * Creates a new socket for the given `nsp`.\n *\n * @return {Socket}\n * @api public\n */\n\nManager.prototype.socket = function(nsp){\n  var socket = this.nsps[nsp];\n  if (!socket) {\n    socket = new Socket(this, nsp);\n    this.nsps[nsp] = socket;\n    var self = this;\n    socket.on('connect', function(){\n      socket.id = self.engine.id;\n      if (!~indexOf(self.connected, socket)) {\n        self.connected.push(socket);\n      }\n    });\n  }\n  return socket;\n};\n\n/**\n * Called upon a socket close.\n *\n * @param {Socket} socket\n */\n\nManager.prototype.destroy = function(socket){\n  var index = indexOf(this.connected, socket);\n  if (~index) this.connected.splice(index, 1);\n  if (this.connected.length) return;\n\n  this.close();\n};\n\n/**\n * Writes a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nManager.prototype.packet = function(packet){\n  debug('writing packet %j', packet);\n  var self = this;\n\n  if (!self.encoding) {\n    // encode, then write to engine with result\n    self.encoding = true;\n    this.encoder.encode(packet, function(encodedPackets) {\n      for (var i = 0; i < encodedPackets.length; i++) {\n        self.engine.write(encodedPackets[i]);\n      }\n      self.encoding = false;\n      self.processPacketQueue();\n    });\n  } else { // add packet to the queue\n    self.packetBuffer.push(packet);\n  }\n};\n\n/**\n * If packet buffer is non-empty, begins encoding the\n * next packet in line.\n *\n * @api private\n */\n\nManager.prototype.processPacketQueue = function() {\n  if (this.packetBuffer.length > 0 && !this.encoding) {\n    var pack = this.packetBuffer.shift();\n    this.packet(pack);\n  }\n};\n\n/**\n * Clean up transport subscriptions and packet buffer.\n *\n * @api private\n */\n\nManager.prototype.cleanup = function(){\n  var sub;\n  while (sub = this.subs.shift()) sub.destroy();\n\n  this.packetBuffer = [];\n  this.encoding = false;\n\n  this.decoder.destroy();\n};\n\n/**\n * Close the current socket.\n *\n * @api private\n */\n\nManager.prototype.close =\nManager.prototype.disconnect = function(){\n  this.skipReconnect = true;\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.engine && this.engine.close();\n};\n\n/**\n * Called upon engine close.\n *\n * @api private\n */\n\nManager.prototype.onclose = function(reason){\n  debug('close');\n  this.cleanup();\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.emit('close', reason);\n  if (this._reconnection && !this.skipReconnect) {\n    this.reconnect();\n  }\n};\n\n/**\n * Attempt a reconnection.\n *\n * @api private\n */\n\nManager.prototype.reconnect = function(){\n  if (this.reconnecting || this.skipReconnect) return this;\n\n  var self = this;\n\n  if (this.backoff.attempts >= this._reconnectionAttempts) {\n    debug('reconnect failed');\n    this.backoff.reset();\n    this.emitAll('reconnect_failed');\n    this.reconnecting = false;\n  } else {\n    var delay = this.backoff.duration();\n    debug('will wait %dms before reconnect attempt', delay);\n\n    this.reconnecting = true;\n    var timer = setTimeout(function(){\n      if (self.skipReconnect) return;\n\n      debug('attempting reconnect');\n      self.emitAll('reconnect_attempt', self.backoff.attempts);\n      self.emitAll('reconnecting', self.backoff.attempts);\n\n      // check again for the case socket closed in above events\n      if (self.skipReconnect) return;\n\n      self.open(function(err){\n        if (err) {\n          debug('reconnect attempt error');\n          self.reconnecting = false;\n          self.reconnect();\n          self.emitAll('reconnect_error', err.data);\n        } else {\n          debug('reconnect success');\n          self.onreconnect();\n        }\n      });\n    }, delay);\n\n    this.subs.push({\n      destroy: function(){\n        clearTimeout(timer);\n      }\n    });\n  }\n};\n\n/**\n * Called upon successful reconnect.\n *\n * @api private\n */\n\nManager.prototype.onreconnect = function(){\n  var attempt = this.backoff.attempts;\n  this.reconnecting = false;\n  this.backoff.reset();\n  this.updateSocketIds();\n  this.emitAll('reconnect', attempt);\n};\n\n},{\"./on\":4,\"./socket\":5,\"./url\":6,\"backo2\":7,\"component-bind\":8,\"component-emitter\":9,\"debug\":10,\"engine.io-client\":11,\"indexof\":40,\"object-component\":41,\"socket.io-parser\":44}],4:[function(_dereq_,module,exports){\n\n/**\n * Module exports.\n */\n\nmodule.exports = on;\n\n/**\n * Helper for subscriptions.\n *\n * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`\n * @param {String} event name\n * @param {Function} callback\n * @api public\n */\n\nfunction on(obj, ev, fn) {\n  obj.on(ev, fn);\n  return {\n    destroy: function(){\n      obj.removeListener(ev, fn);\n    }\n  };\n}\n\n},{}],5:[function(_dereq_,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar parser = _dereq_('socket.io-parser');\nvar Emitter = _dereq_('component-emitter');\nvar toArray = _dereq_('to-array');\nvar on = _dereq_('./on');\nvar bind = _dereq_('component-bind');\nvar debug = _dereq_('debug')('socket.io-client:socket');\nvar hasBin = _dereq_('has-binary');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = Socket;\n\n/**\n * Internal events (blacklisted).\n * These events can't be emitted by the user.\n *\n * @api private\n */\n\nvar events = {\n  connect: 1,\n  connect_error: 1,\n  connect_timeout: 1,\n  disconnect: 1,\n  error: 1,\n  reconnect: 1,\n  reconnect_attempt: 1,\n  reconnect_failed: 1,\n  reconnect_error: 1,\n  reconnecting: 1\n};\n\n/**\n * Shortcut to `Emitter#emit`.\n */\n\nvar emit = Emitter.prototype.emit;\n\n/**\n * `Socket` constructor.\n *\n * @api public\n */\n\nfunction Socket(io, nsp){\n  this.io = io;\n  this.nsp = nsp;\n  this.json = this; // compat\n  this.ids = 0;\n  this.acks = {};\n  if (this.io.autoConnect) this.open();\n  this.receiveBuffer = [];\n  this.sendBuffer = [];\n  this.connected = false;\n  this.disconnected = true;\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Subscribe to open, close and packet events\n *\n * @api private\n */\n\nSocket.prototype.subEvents = function() {\n  if (this.subs) return;\n\n  var io = this.io;\n  this.subs = [\n    on(io, 'open', bind(this, 'onopen')),\n    on(io, 'packet', bind(this, 'onpacket')),\n    on(io, 'close', bind(this, 'onclose'))\n  ];\n};\n\n/**\n * \"Opens\" the socket.\n *\n * @api public\n */\n\nSocket.prototype.open =\nSocket.prototype.connect = function(){\n  if (this.connected) return this;\n\n  this.subEvents();\n  this.io.open(); // ensure open\n  if ('open' == this.io.readyState) this.onopen();\n  return this;\n};\n\n/**\n * Sends a `message` event.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.send = function(){\n  var args = toArray(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n\n/**\n * Override `emit`.\n * If the event is in `events`, it's emitted normally.\n *\n * @param {String} event name\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.emit = function(ev){\n  if (events.hasOwnProperty(ev)) {\n    emit.apply(this, arguments);\n    return this;\n  }\n\n  var args = toArray(arguments);\n  var parserType = parser.EVENT; // default\n  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary\n  var packet = { type: parserType, data: args };\n\n  // event ack callback\n  if ('function' == typeof args[args.length - 1]) {\n    debug('emitting packet with ack id %d', this.ids);\n    this.acks[this.ids] = args.pop();\n    packet.id = this.ids++;\n  }\n\n  if (this.connected) {\n    this.packet(packet);\n  } else {\n    this.sendBuffer.push(packet);\n  }\n\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.packet = function(packet){\n  packet.nsp = this.nsp;\n  this.io.packet(packet);\n};\n\n/**\n * Called upon engine `open`.\n *\n * @api private\n */\n\nSocket.prototype.onopen = function(){\n  debug('transport is open - connecting');\n\n  // write connect packet if necessary\n  if ('/' != this.nsp) {\n    this.packet({ type: parser.CONNECT });\n  }\n};\n\n/**\n * Called upon engine `close`.\n *\n * @param {String} reason\n * @api private\n */\n\nSocket.prototype.onclose = function(reason){\n  debug('close (%s)', reason);\n  this.connected = false;\n  this.disconnected = true;\n  delete this.id;\n  this.emit('disconnect', reason);\n};\n\n/**\n * Called with socket packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onpacket = function(packet){\n  if (packet.nsp != this.nsp) return;\n\n  switch (packet.type) {\n    case parser.CONNECT:\n      this.onconnect();\n      break;\n\n    case parser.EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.BINARY_EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.ACK:\n      this.onack(packet);\n      break;\n\n    case parser.BINARY_ACK:\n      this.onack(packet);\n      break;\n\n    case parser.DISCONNECT:\n      this.ondisconnect();\n      break;\n\n    case parser.ERROR:\n      this.emit('error', packet.data);\n      break;\n  }\n};\n\n/**\n * Called upon a server event.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onevent = function(packet){\n  var args = packet.data || [];\n  debug('emitting event %j', args);\n\n  if (null != packet.id) {\n    debug('attaching ack callback to event');\n    args.push(this.ack(packet.id));\n  }\n\n  if (this.connected) {\n    emit.apply(this, args);\n  } else {\n    this.receiveBuffer.push(args);\n  }\n};\n\n/**\n * Produces an ack callback to emit with an event.\n *\n * @api private\n */\n\nSocket.prototype.ack = function(id){\n  var self = this;\n  var sent = false;\n  return function(){\n    // prevent double callbacks\n    if (sent) return;\n    sent = true;\n    var args = toArray(arguments);\n    debug('sending ack %j', args);\n\n    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;\n    self.packet({\n      type: type,\n      id: id,\n      data: args\n    });\n  };\n};\n\n/**\n * Called upon a server acknowlegement.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onack = function(packet){\n  debug('calling ack %s with %j', packet.id, packet.data);\n  var fn = this.acks[packet.id];\n  fn.apply(this, packet.data);\n  delete this.acks[packet.id];\n};\n\n/**\n * Called upon server connect.\n *\n * @api private\n */\n\nSocket.prototype.onconnect = function(){\n  this.connected = true;\n  this.disconnected = false;\n  this.emit('connect');\n  this.emitBuffered();\n};\n\n/**\n * Emit buffered events (received and emitted).\n *\n * @api private\n */\n\nSocket.prototype.emitBuffered = function(){\n  var i;\n  for (i = 0; i < this.receiveBuffer.length; i++) {\n    emit.apply(this, this.receiveBuffer[i]);\n  }\n  this.receiveBuffer = [];\n\n  for (i = 0; i < this.sendBuffer.length; i++) {\n    this.packet(this.sendBuffer[i]);\n  }\n  this.sendBuffer = [];\n};\n\n/**\n * Called upon server disconnect.\n *\n * @api private\n */\n\nSocket.prototype.ondisconnect = function(){\n  debug('server disconnect (%s)', this.nsp);\n  this.destroy();\n  this.onclose('io server disconnect');\n};\n\n/**\n * Called upon forced client/server side disconnections,\n * this method ensures the manager stops tracking us and\n * that reconnections don't get triggered for this.\n *\n * @api private.\n */\n\nSocket.prototype.destroy = function(){\n  if (this.subs) {\n    // clean subscriptions to avoid reconnections\n    for (var i = 0; i < this.subs.length; i++) {\n      this.subs[i].destroy();\n    }\n    this.subs = null;\n  }\n\n  this.io.destroy(this);\n};\n\n/**\n * Disconnects the socket manually.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.close =\nSocket.prototype.disconnect = function(){\n  if (this.connected) {\n    debug('performing disconnect (%s)', this.nsp);\n    this.packet({ type: parser.DISCONNECT });\n  }\n\n  // remove socket from pool\n  this.destroy();\n\n  if (this.connected) {\n    // fire events\n    this.onclose('io client disconnect');\n  }\n  return this;\n};\n\n},{\"./on\":4,\"component-bind\":8,\"component-emitter\":9,\"debug\":10,\"has-binary\":36,\"socket.io-parser\":44,\"to-array\":48}],6:[function(_dereq_,module,exports){\n(function (global){\n\n/**\n * Module dependencies.\n */\n\nvar parseuri = _dereq_('parseuri');\nvar debug = _dereq_('debug')('socket.io-client:url');\n\n/**\n * Module exports.\n */\n\nmodule.exports = url;\n\n/**\n * URL parser.\n *\n * @param {String} url\n * @param {Object} An object meant to mimic window.location.\n *                 Defaults to window.location.\n * @api public\n */\n\nfunction url(uri, loc){\n  var obj = uri;\n\n  // default to window.location\n  var loc = loc || global.location;\n  if (null == uri) uri = loc.protocol + '//' + loc.host;\n\n  // relative path support\n  if ('string' == typeof uri) {\n    if ('/' == uri.charAt(0)) {\n      if ('/' == uri.charAt(1)) {\n        uri = loc.protocol + uri;\n      } else {\n        uri = loc.hostname + uri;\n      }\n    }\n\n    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n      debug('protocol-less url %s', uri);\n      if ('undefined' != typeof loc) {\n        uri = loc.protocol + '//' + uri;\n      } else {\n        uri = 'https://' + uri;\n      }\n    }\n\n    // parse\n    debug('parse %s', uri);\n    obj = parseuri(uri);\n  }\n\n  // make sure we treat `localhost:80` and `localhost` equally\n  if (!obj.port) {\n    if (/^(http|ws)$/.test(obj.protocol)) {\n      obj.port = '80';\n    }\n    else if (/^(http|ws)s$/.test(obj.protocol)) {\n      obj.port = '443';\n    }\n  }\n\n  obj.path = obj.path || '/';\n\n  // define unique id\n  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;\n  // define href\n  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));\n\n  return obj;\n}\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"debug\":10,\"parseuri\":42}],7:[function(_dereq_,module,exports){\n\n/**\n * Expose `Backoff`.\n */\n\nmodule.exports = Backoff;\n\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\nBackoff.prototype.duration = function(){\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand =  Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\n\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\nBackoff.prototype.reset = function(){\n  this.attempts = 0;\n};\n\n/**\n * Set the minimum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMin = function(min){\n  this.ms = min;\n};\n\n/**\n * Set the maximum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMax = function(max){\n  this.max = max;\n};\n\n/**\n * Set the jitter\n *\n * @api public\n */\n\nBackoff.prototype.setJitter = function(jitter){\n  this.jitter = jitter;\n};\n\n\n},{}],8:[function(_dereq_,module,exports){\n/**\n * Slice reference.\n */\n\nvar slice = [].slice;\n\n/**\n * Bind `obj` to `fn`.\n *\n * @param {Object} obj\n * @param {Function|String} fn or string\n * @return {Function}\n * @api public\n */\n\nmodule.exports = function(obj, fn){\n  if ('string' == typeof fn) fn = obj[fn];\n  if ('function' != typeof fn) throw new Error('bind() requires a function');\n  var args = slice.call(arguments, 2);\n  return function(){\n    return fn.apply(obj, args.concat(slice.call(arguments)));\n  }\n};\n\n},{}],9:[function(_dereq_,module,exports){\n\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n},{}],10:[function(_dereq_,module,exports){\n\n/**\n * Expose `debug()` as the module.\n */\n\nmodule.exports = debug;\n\n/**\n * Create a debugger with the given `name`.\n *\n * @param {String} name\n * @return {Type}\n * @api public\n */\n\nfunction debug(name) {\n  if (!debug.enabled(name)) return function(){};\n\n  return function(fmt){\n    fmt = coerce(fmt);\n\n    var curr = new Date;\n    var ms = curr - (debug[name] || curr);\n    debug[name] = curr;\n\n    fmt = name\n      + ' '\n      + fmt\n      + ' +' + debug.humanize(ms);\n\n    // This hackery is required for IE8\n    // where `console.log` doesn't have 'apply'\n    window.console\n      && console.log\n      && Function.prototype.apply.call(console.log, console, arguments);\n  }\n}\n\n/**\n * The currently active debug mode names.\n */\n\ndebug.names = [];\ndebug.skips = [];\n\n/**\n * Enables a debug mode by name. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} name\n * @api public\n */\n\ndebug.enable = function(name) {\n  try {\n    localStorage.debug = name;\n  } catch(e){}\n\n  var split = (name || '').split(/[\\s,]+/)\n    , len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    name = split[i].replace('*', '.*?');\n    if (name[0] === '-') {\n      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));\n    }\n    else {\n      debug.names.push(new RegExp('^' + name + '$'));\n    }\n  }\n};\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\ndebug.disable = function(){\n  debug.enable('');\n};\n\n/**\n * Humanize the given `ms`.\n *\n * @param {Number} m\n * @return {String}\n * @api private\n */\n\ndebug.humanize = function(ms) {\n  var sec = 1000\n    , min = 60 * 1000\n    , hour = 60 * min;\n\n  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';\n  if (ms >= min) return (ms / min).toFixed(1) + 'm';\n  if (ms >= sec) return (ms / sec | 0) + 's';\n  return ms + 'ms';\n};\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\ndebug.enabled = function(name) {\n  for (var i = 0, len = debug.skips.length; i < len; i++) {\n    if (debug.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (var i = 0, len = debug.names.length; i < len; i++) {\n    if (debug.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Coerce `val`.\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n// persist\n\ntry {\n  if (window.localStorage) debug.enable(localStorage.debug);\n} catch(e){}\n\n},{}],11:[function(_dereq_,module,exports){\n\nmodule.exports =  _dereq_('./lib/');\n\n},{\"./lib/\":12}],12:[function(_dereq_,module,exports){\n\nmodule.exports = _dereq_('./socket');\n\n/**\n * Exports parser\n *\n * @api public\n *\n */\nmodule.exports.parser = _dereq_('engine.io-parser');\n\n},{\"./socket\":13,\"engine.io-parser\":25}],13:[function(_dereq_,module,exports){\n(function (global){\n/**\n * Module dependencies.\n */\n\nvar transports = _dereq_('./transports');\nvar Emitter = _dereq_('component-emitter');\nvar debug = _dereq_('debug')('engine.io-client:socket');\nvar index = _dereq_('indexof');\nvar parser = _dereq_('engine.io-parser');\nvar parseuri = _dereq_('parseuri');\nvar parsejson = _dereq_('parsejson');\nvar parseqs = _dereq_('parseqs');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Socket;\n\n/**\n * Noop function.\n *\n * @api private\n */\n\nfunction noop(){}\n\n/**\n * Socket constructor.\n *\n * @param {String|Object} uri or options\n * @param {Object} options\n * @api public\n */\n\nfunction Socket(uri, opts){\n  if (!(this instanceof Socket)) return new Socket(uri, opts);\n\n  opts = opts || {};\n\n  if (uri && 'object' == typeof uri) {\n    opts = uri;\n    uri = null;\n  }\n\n  if (uri) {\n    uri = parseuri(uri);\n    opts.host = uri.host;\n    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';\n    opts.port = uri.port;\n    if (uri.query) opts.query = uri.query;\n  }\n\n  this.secure = null != opts.secure ? opts.secure :\n    (global.location && 'https:' == location.protocol);\n\n  if (opts.host) {\n    var pieces = opts.host.split(':');\n    opts.hostname = pieces.shift();\n    if (pieces.length) {\n      opts.port = pieces.pop();\n    } else if (!opts.port) {\n      // if no port is specified manually, use the protocol default\n      opts.port = this.secure ? '443' : '80';\n    }\n  }\n\n  this.agent = opts.agent || false;\n  this.hostname = opts.hostname ||\n    (global.location ? location.hostname : 'localhost');\n  this.port = opts.port || (global.location && location.port ?\n       location.port :\n       (this.secure ? 443 : 80));\n  this.query = opts.query || {};\n  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);\n  this.upgrade = false !== opts.upgrade;\n  this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n  this.forceJSONP = !!opts.forceJSONP;\n  this.jsonp = false !== opts.jsonp;\n  this.forceBase64 = !!opts.forceBase64;\n  this.enablesXDR = !!opts.enablesXDR;\n  this.timestampParam = opts.timestampParam || 't';\n  this.timestampRequests = opts.timestampRequests;\n  this.transports = opts.transports || ['polling', 'websocket'];\n  this.readyState = '';\n  this.writeBuffer = [];\n  this.callbackBuffer = [];\n  this.policyPort = opts.policyPort || 843;\n  this.rememberUpgrade = opts.rememberUpgrade || false;\n  this.binaryType = null;\n  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx || null;\n  this.key = opts.key || null;\n  this.passphrase = opts.passphrase || null;\n  this.cert = opts.cert || null;\n  this.ca = opts.ca || null;\n  this.ciphers = opts.ciphers || null;\n  this.rejectUnauthorized = opts.rejectUnauthorized || null;\n\n  this.open();\n}\n\nSocket.priorWebsocketSuccess = false;\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nSocket.protocol = parser.protocol; // this is an int\n\n/**\n * Expose deps for legacy compatibility\n * and standalone browser access.\n */\n\nSocket.Socket = Socket;\nSocket.Transport = _dereq_('./transport');\nSocket.transports = _dereq_('./transports');\nSocket.parser = _dereq_('engine.io-parser');\n\n/**\n * Creates transport of the given type.\n *\n * @param {String} transport name\n * @return {Transport}\n * @api private\n */\n\nSocket.prototype.createTransport = function (name) {\n  debug('creating transport \"%s\"', name);\n  var query = clone(this.query);\n\n  // append engine.io protocol identifier\n  query.EIO = parser.protocol;\n\n  // transport name\n  query.transport = name;\n\n  // session id if we already have one\n  if (this.id) query.sid = this.id;\n\n  var transport = new transports[name]({\n    agent: this.agent,\n    hostname: this.hostname,\n    port: this.port,\n    secure: this.secure,\n    path: this.path,\n    query: query,\n    forceJSONP: this.forceJSONP,\n    jsonp: this.jsonp,\n    forceBase64: this.forceBase64,\n    enablesXDR: this.enablesXDR,\n    timestampRequests: this.timestampRequests,\n    timestampParam: this.timestampParam,\n    policyPort: this.policyPort,\n    socket: this,\n    pfx: this.pfx,\n    key: this.key,\n    passphrase: this.passphrase,\n    cert: this.cert,\n    ca: this.ca,\n    ciphers: this.ciphers,\n    rejectUnauthorized: this.rejectUnauthorized\n  });\n\n  return transport;\n};\n\nfunction clone (obj) {\n  var o = {};\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      o[i] = obj[i];\n    }\n  }\n  return o;\n}\n\n/**\n * Initializes transport to use and starts probe.\n *\n * @api private\n */\nSocket.prototype.open = function () {\n  var transport;\n  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {\n    transport = 'websocket';\n  } else if (0 == this.transports.length) {\n    // Emit error on next tick so it can be listened to\n    var self = this;\n    setTimeout(function() {\n      self.emit('error', 'No transports available');\n    }, 0);\n    return;\n  } else {\n    transport = this.transports[0];\n  }\n  this.readyState = 'opening';\n\n  // Retry with the next transport if the transport is disabled (jsonp: false)\n  var transport;\n  try {\n    transport = this.createTransport(transport);\n  } catch (e) {\n    this.transports.shift();\n    this.open();\n    return;\n  }\n\n  transport.open();\n  this.setTransport(transport);\n};\n\n/**\n * Sets the current transport. Disables the existing one (if any).\n *\n * @api private\n */\n\nSocket.prototype.setTransport = function(transport){\n  debug('setting transport %s', transport.name);\n  var self = this;\n\n  if (this.transport) {\n    debug('clearing existing transport %s', this.transport.name);\n    this.transport.removeAllListeners();\n  }\n\n  // set up transport\n  this.transport = transport;\n\n  // set up transport listeners\n  transport\n  .on('drain', function(){\n    self.onDrain();\n  })\n  .on('packet', function(packet){\n    self.onPacket(packet);\n  })\n  .on('error', function(e){\n    self.onError(e);\n  })\n  .on('close', function(){\n    self.onClose('transport close');\n  });\n};\n\n/**\n * Probes a transport.\n *\n * @param {String} transport name\n * @api private\n */\n\nSocket.prototype.probe = function (name) {\n  debug('probing transport \"%s\"', name);\n  var transport = this.createTransport(name, { probe: 1 })\n    , failed = false\n    , self = this;\n\n  Socket.priorWebsocketSuccess = false;\n\n  function onTransportOpen(){\n    if (self.onlyBinaryUpgrades) {\n      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n      failed = failed || upgradeLosesBinary;\n    }\n    if (failed) return;\n\n    debug('probe transport \"%s\" opened', name);\n    transport.send([{ type: 'ping', data: 'probe' }]);\n    transport.once('packet', function (msg) {\n      if (failed) return;\n      if ('pong' == msg.type && 'probe' == msg.data) {\n        debug('probe transport \"%s\" pong', name);\n        self.upgrading = true;\n        self.emit('upgrading', transport);\n        if (!transport) return;\n        Socket.priorWebsocketSuccess = 'websocket' == transport.name;\n\n        debug('pausing current transport \"%s\"', self.transport.name);\n        self.transport.pause(function () {\n          if (failed) return;\n          if ('closed' == self.readyState) return;\n          debug('changing transport and sending upgrade packet');\n\n          cleanup();\n\n          self.setTransport(transport);\n          transport.send([{ type: 'upgrade' }]);\n          self.emit('upgrade', transport);\n          transport = null;\n          self.upgrading = false;\n          self.flush();\n        });\n      } else {\n        debug('probe transport \"%s\" failed', name);\n        var err = new Error('probe error');\n        err.transport = transport.name;\n        self.emit('upgradeError', err);\n      }\n    });\n  }\n\n  function freezeTransport() {\n    if (failed) return;\n\n    // Any callback called by transport should be ignored since now\n    failed = true;\n\n    cleanup();\n\n    transport.close();\n    transport = null;\n  }\n\n  //Handle any error that happens while probing\n  function onerror(err) {\n    var error = new Error('probe error: ' + err);\n    error.transport = transport.name;\n\n    freezeTransport();\n\n    debug('probe transport \"%s\" failed because of error: %s', name, err);\n\n    self.emit('upgradeError', error);\n  }\n\n  function onTransportClose(){\n    onerror(\"transport closed\");\n  }\n\n  //When the socket is closed while we're probing\n  function onclose(){\n    onerror(\"socket closed\");\n  }\n\n  //When the socket is upgraded while we're probing\n  function onupgrade(to){\n    if (transport && to.name != transport.name) {\n      debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n      freezeTransport();\n    }\n  }\n\n  //Remove all listeners on the transport and on self\n  function cleanup(){\n    transport.removeListener('open', onTransportOpen);\n    transport.removeListener('error', onerror);\n    transport.removeListener('close', onTransportClose);\n    self.removeListener('close', onclose);\n    self.removeListener('upgrading', onupgrade);\n  }\n\n  transport.once('open', onTransportOpen);\n  transport.once('error', onerror);\n  transport.once('close', onTransportClose);\n\n  this.once('close', onclose);\n  this.once('upgrading', onupgrade);\n\n  transport.open();\n\n};\n\n/**\n * Called when connection is deemed open.\n *\n * @api public\n */\n\nSocket.prototype.onOpen = function () {\n  debug('socket open');\n  this.readyState = 'open';\n  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;\n  this.emit('open');\n  this.flush();\n\n  // we check for `readyState` in case an `open`\n  // listener already closed the socket\n  if ('open' == this.readyState && this.upgrade && this.transport.pause) {\n    debug('starting upgrade probes');\n    for (var i = 0, l = this.upgrades.length; i < l; i++) {\n      this.probe(this.upgrades[i]);\n    }\n  }\n};\n\n/**\n * Handles a packet.\n *\n * @api private\n */\n\nSocket.prototype.onPacket = function (packet) {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n\n    this.emit('packet', packet);\n\n    // Socket is live - any packet counts\n    this.emit('heartbeat');\n\n    switch (packet.type) {\n      case 'open':\n        this.onHandshake(parsejson(packet.data));\n        break;\n\n      case 'pong':\n        this.setPing();\n        break;\n\n      case 'error':\n        var err = new Error('server error');\n        err.code = packet.data;\n        this.emit('error', err);\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        break;\n    }\n  } else {\n    debug('packet received with socket readyState \"%s\"', this.readyState);\n  }\n};\n\n/**\n * Called upon handshake completion.\n *\n * @param {Object} handshake obj\n * @api private\n */\n\nSocket.prototype.onHandshake = function (data) {\n  this.emit('handshake', data);\n  this.id = data.sid;\n  this.transport.query.sid = data.sid;\n  this.upgrades = this.filterUpgrades(data.upgrades);\n  this.pingInterval = data.pingInterval;\n  this.pingTimeout = data.pingTimeout;\n  this.onOpen();\n  // In case open handler closes socket\n  if  ('closed' == this.readyState) return;\n  this.setPing();\n\n  // Prolong liveness of socket on heartbeat\n  this.removeListener('heartbeat', this.onHeartbeat);\n  this.on('heartbeat', this.onHeartbeat);\n};\n\n/**\n * Resets ping timeout.\n *\n * @api private\n */\n\nSocket.prototype.onHeartbeat = function (timeout) {\n  clearTimeout(this.pingTimeoutTimer);\n  var self = this;\n  self.pingTimeoutTimer = setTimeout(function () {\n    if ('closed' == self.readyState) return;\n    self.onClose('ping timeout');\n  }, timeout || (self.pingInterval + self.pingTimeout));\n};\n\n/**\n * Pings server every `this.pingInterval` and expects response\n * within `this.pingTimeout` or closes connection.\n *\n * @api private\n */\n\nSocket.prototype.setPing = function () {\n  var self = this;\n  clearTimeout(self.pingIntervalTimer);\n  self.pingIntervalTimer = setTimeout(function () {\n    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\n    self.ping();\n    self.onHeartbeat(self.pingTimeout);\n  }, self.pingInterval);\n};\n\n/**\n* Sends a ping packet.\n*\n* @api public\n*/\n\nSocket.prototype.ping = function () {\n  this.sendPacket('ping');\n};\n\n/**\n * Called on `drain` event\n *\n * @api private\n */\n\nSocket.prototype.onDrain = function() {\n  for (var i = 0; i < this.prevBufferLen; i++) {\n    if (this.callbackBuffer[i]) {\n      this.callbackBuffer[i]();\n    }\n  }\n\n  this.writeBuffer.splice(0, this.prevBufferLen);\n  this.callbackBuffer.splice(0, this.prevBufferLen);\n\n  // setting prevBufferLen = 0 is very important\n  // for example, when upgrading, upgrade packet is sent over,\n  // and a nonzero prevBufferLen could cause problems on `drain`\n  this.prevBufferLen = 0;\n\n  if (this.writeBuffer.length == 0) {\n    this.emit('drain');\n  } else {\n    this.flush();\n  }\n};\n\n/**\n * Flush write buffers.\n *\n * @api private\n */\n\nSocket.prototype.flush = function () {\n  if ('closed' != this.readyState && this.transport.writable &&\n    !this.upgrading && this.writeBuffer.length) {\n    debug('flushing %d packets in socket', this.writeBuffer.length);\n    this.transport.send(this.writeBuffer);\n    // keep track of current length of writeBuffer\n    // splice writeBuffer and callbackBuffer on `drain`\n    this.prevBufferLen = this.writeBuffer.length;\n    this.emit('flush');\n  }\n};\n\n/**\n * Sends a message.\n *\n * @param {String} message.\n * @param {Function} callback function.\n * @return {Socket} for chaining.\n * @api public\n */\n\nSocket.prototype.write =\nSocket.prototype.send = function (msg, fn) {\n  this.sendPacket('message', msg, fn);\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {String} packet type.\n * @param {String} data.\n * @param {Function} callback function.\n * @api private\n */\n\nSocket.prototype.sendPacket = function (type, data, fn) {\n  if ('closing' == this.readyState || 'closed' == this.readyState) {\n    return;\n  }\n\n  var packet = { type: type, data: data };\n  this.emit('packetCreate', packet);\n  this.writeBuffer.push(packet);\n  this.callbackBuffer.push(fn);\n  this.flush();\n};\n\n/**\n * Closes the connection.\n *\n * @api private\n */\n\nSocket.prototype.close = function () {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    this.readyState = 'closing';\n\n    var self = this;\n\n    function close() {\n      self.onClose('forced close');\n      debug('socket closing - telling transport to close');\n      self.transport.close();\n    }\n\n    function cleanupAndClose() {\n      self.removeListener('upgrade', cleanupAndClose);\n      self.removeListener('upgradeError', cleanupAndClose);\n      close();\n    }\n\n    function waitForUpgrade() {\n      // wait for upgrade to finish since we can't send packets while pausing a transport\n      self.once('upgrade', cleanupAndClose);\n      self.once('upgradeError', cleanupAndClose);\n    }\n\n    if (this.writeBuffer.length) {\n      this.once('drain', function() {\n        if (this.upgrading) {\n          waitForUpgrade();\n        } else {\n          close();\n        }\n      });\n    } else if (this.upgrading) {\n      waitForUpgrade();\n    } else {\n      close();\n    }\n  }\n\n  return this;\n};\n\n/**\n * Called upon transport error\n *\n * @api private\n */\n\nSocket.prototype.onError = function (err) {\n  debug('socket error %j', err);\n  Socket.priorWebsocketSuccess = false;\n  this.emit('error', err);\n  this.onClose('transport error', err);\n};\n\n/**\n * Called upon transport close.\n *\n * @api private\n */\n\nSocket.prototype.onClose = function (reason, desc) {\n  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {\n    debug('socket close with reason: \"%s\"', reason);\n    var self = this;\n\n    // clear timers\n    clearTimeout(this.pingIntervalTimer);\n    clearTimeout(this.pingTimeoutTimer);\n\n    // clean buffers in next tick, so developers can still\n    // grab the buffers on `close` event\n    setTimeout(function() {\n      self.writeBuffer = [];\n      self.callbackBuffer = [];\n      self.prevBufferLen = 0;\n    }, 0);\n\n    // stop event from firing again for transport\n    this.transport.removeAllListeners('close');\n\n    // ensure transport won't stay open\n    this.transport.close();\n\n    // ignore further transport communication\n    this.transport.removeAllListeners();\n\n    // set ready state\n    this.readyState = 'closed';\n\n    // clear session id\n    this.id = null;\n\n    // emit close event\n    this.emit('close', reason, desc);\n  }\n};\n\n/**\n * Filters upgrades, returning only those matching client transports.\n *\n * @param {Array} server upgrades\n * @api private\n *\n */\n\nSocket.prototype.filterUpgrades = function (upgrades) {\n  var filteredUpgrades = [];\n  for (var i = 0, j = upgrades.length; i<j; i++) {\n    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\n  }\n  return filteredUpgrades;\n};\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./transport\":14,\"./transports\":15,\"component-emitter\":9,\"debug\":22,\"engine.io-parser\":25,\"indexof\":40,\"parsejson\":32,\"parseqs\":33,\"parseuri\":34}],14:[function(_dereq_,module,exports){\n/**\n * Module dependencies.\n */\n\nvar parser = _dereq_('engine.io-parser');\nvar Emitter = _dereq_('component-emitter');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Transport;\n\n/**\n * Transport abstract constructor.\n *\n * @param {Object} options.\n * @api private\n */\n\nfunction Transport (opts) {\n  this.path = opts.path;\n  this.hostname = opts.hostname;\n  this.port = opts.port;\n  this.secure = opts.secure;\n  this.query = opts.query;\n  this.timestampParam = opts.timestampParam;\n  this.timestampRequests = opts.timestampRequests;\n  this.readyState = '';\n  this.agent = opts.agent || false;\n  this.socket = opts.socket;\n  this.enablesXDR = opts.enablesXDR;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Transport.prototype);\n\n/**\n * A counter used to prevent collisions in the timestamps used\n * for cache busting.\n */\n\nTransport.timestamps = 0;\n\n/**\n * Emits an error.\n *\n * @param {String} str\n * @return {Transport} for chaining\n * @api public\n */\n\nTransport.prototype.onError = function (msg, desc) {\n  var err = new Error(msg);\n  err.type = 'TransportError';\n  err.description = desc;\n  this.emit('error', err);\n  return this;\n};\n\n/**\n * Opens the transport.\n *\n * @api public\n */\n\nTransport.prototype.open = function () {\n  if ('closed' == this.readyState || '' == this.readyState) {\n    this.readyState = 'opening';\n    this.doOpen();\n  }\n\n  return this;\n};\n\n/**\n * Closes the transport.\n *\n * @api private\n */\n\nTransport.prototype.close = function () {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    this.doClose();\n    this.onClose();\n  }\n\n  return this;\n};\n\n/**\n * Sends multiple packets.\n *\n * @param {Array} packets\n * @api private\n */\n\nTransport.prototype.send = function(packets){\n  if ('open' == this.readyState) {\n    this.write(packets);\n  } else {\n    throw new Error('Transport not open');\n  }\n};\n\n/**\n * Called upon open\n *\n * @api private\n */\n\nTransport.prototype.onOpen = function () {\n  this.readyState = 'open';\n  this.writable = true;\n  this.emit('open');\n};\n\n/**\n * Called with data.\n *\n * @param {String} data\n * @api private\n */\n\nTransport.prototype.onData = function(data){\n  var packet = parser.decodePacket(data, this.socket.binaryType);\n  this.onPacket(packet);\n};\n\n/**\n * Called with a decoded packet.\n */\n\nTransport.prototype.onPacket = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon close.\n *\n * @api private\n */\n\nTransport.prototype.onClose = function () {\n  this.readyState = 'closed';\n  this.emit('close');\n};\n\n},{\"component-emitter\":9,\"engine.io-parser\":25}],15:[function(_dereq_,module,exports){\n(function (global){\n/**\n * Module dependencies\n */\n\nvar XMLHttpRequest = _dereq_('xmlhttprequest');\nvar XHR = _dereq_('./polling-xhr');\nvar JSONP = _dereq_('./polling-jsonp');\nvar websocket = _dereq_('./websocket');\n\n/**\n * Export transports.\n */\n\nexports.polling = polling;\nexports.websocket = websocket;\n\n/**\n * Polling transport polymorphic constructor.\n * Decides on xhr vs jsonp based on feature detection.\n *\n * @api private\n */\n\nfunction polling(opts){\n  var xhr;\n  var xd = false;\n  var xs = false;\n  var jsonp = false !== opts.jsonp;\n\n  if (global.location) {\n    var isSSL = 'https:' == location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    xd = opts.hostname != location.hostname || port != opts.port;\n    xs = opts.secure != isSSL;\n  }\n\n  opts.xdomain = xd;\n  opts.xscheme = xs;\n  xhr = new XMLHttpRequest(opts);\n\n  if ('open' in xhr && !opts.forceJSONP) {\n    return new XHR(opts);\n  } else {\n    if (!jsonp) throw new Error('JSONP disabled');\n    return new JSONP(opts);\n  }\n}\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./polling-jsonp\":16,\"./polling-xhr\":17,\"./websocket\":19,\"xmlhttprequest\":20}],16:[function(_dereq_,module,exports){\n(function (global){\n\n/**\n * Module requirements.\n */\n\nvar Polling = _dereq_('./polling');\nvar inherit = _dereq_('component-inherit');\n\n/**\n * Module exports.\n */\n\nmodule.exports = JSONPPolling;\n\n/**\n * Cached regular expressions.\n */\n\nvar rNewline = /\\n/g;\nvar rEscapedNewline = /\\\\n/g;\n\n/**\n * Global JSONP callbacks.\n */\n\nvar callbacks;\n\n/**\n * Callbacks count.\n */\n\nvar index = 0;\n\n/**\n * Noop.\n */\n\nfunction empty () { }\n\n/**\n * JSONP Polling constructor.\n *\n * @param {Object} opts.\n * @api public\n */\n\nfunction JSONPPolling (opts) {\n  Polling.call(this, opts);\n\n  this.query = this.query || {};\n\n  // define global callbacks array if not present\n  // we do this here (lazily) to avoid unneeded global pollution\n  if (!callbacks) {\n    // we need to consider multiple engines in the same page\n    if (!global.___eio) global.___eio = [];\n    callbacks = global.___eio;\n  }\n\n  // callback identifier\n  this.index = callbacks.length;\n\n  // add callback to jsonp global\n  var self = this;\n  callbacks.push(function (msg) {\n    self.onData(msg);\n  });\n\n  // append to query string\n  this.query.j = this.index;\n\n  // prevent spurious errors from being emitted when the window is unloaded\n  if (global.document && global.addEventListener) {\n    global.addEventListener('beforeunload', function () {\n      if (self.script) self.script.onerror = empty;\n    }, false);\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(JSONPPolling, Polling);\n\n/*\n * JSONP only supports binary as base64 encoded strings\n */\n\nJSONPPolling.prototype.supportsBinary = false;\n\n/**\n * Closes the socket.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doClose = function () {\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  if (this.form) {\n    this.form.parentNode.removeChild(this.form);\n    this.form = null;\n    this.iframe = null;\n  }\n\n  Polling.prototype.doClose.call(this);\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doPoll = function () {\n  var self = this;\n  var script = document.createElement('script');\n\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  script.async = true;\n  script.src = this.uri();\n  script.onerror = function(e){\n    self.onError('jsonp poll error',e);\n  };\n\n  var insertAt = document.getElementsByTagName('script')[0];\n  insertAt.parentNode.insertBefore(script, insertAt);\n  this.script = script;\n\n  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);\n  \n  if (isUAgecko) {\n    setTimeout(function () {\n      var iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      document.body.removeChild(iframe);\n    }, 100);\n  }\n};\n\n/**\n * Writes with a hidden iframe.\n *\n * @param {String} data to send\n * @param {Function} called upon flush.\n * @api private\n */\n\nJSONPPolling.prototype.doWrite = function (data, fn) {\n  var self = this;\n\n  if (!this.form) {\n    var form = document.createElement('form');\n    var area = document.createElement('textarea');\n    var id = this.iframeId = 'eio_iframe_' + this.index;\n    var iframe;\n\n    form.className = 'socketio';\n    form.style.position = 'absolute';\n    form.style.top = '-1000px';\n    form.style.left = '-1000px';\n    form.target = id;\n    form.method = 'POST';\n    form.setAttribute('accept-charset', 'utf-8');\n    area.name = 'd';\n    form.appendChild(area);\n    document.body.appendChild(form);\n\n    this.form = form;\n    this.area = area;\n  }\n\n  this.form.action = this.uri();\n\n  function complete () {\n    initIframe();\n    fn();\n  }\n\n  function initIframe () {\n    if (self.iframe) {\n      try {\n        self.form.removeChild(self.iframe);\n      } catch (e) {\n        self.onError('jsonp polling iframe removal error', e);\n      }\n    }\n\n    try {\n      // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n      var html = '<iframe src=\"javascript:0\" name=\"'+ self.iframeId +'\">';\n      iframe = document.createElement(html);\n    } catch (e) {\n      iframe = document.createElement('iframe');\n      iframe.name = self.iframeId;\n      iframe.src = 'javascript:0';\n    }\n\n    iframe.id = self.iframeId;\n\n    self.form.appendChild(iframe);\n    self.iframe = iframe;\n  }\n\n  initIframe();\n\n  // escape \\n to prevent it from being converted into \\r\\n by some UAs\n  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n  data = data.replace(rEscapedNewline, '\\\\\\n');\n  this.area.value = data.replace(rNewline, '\\\\n');\n\n  try {\n    this.form.submit();\n  } catch(e) {}\n\n  if (this.iframe.attachEvent) {\n    this.iframe.onreadystatechange = function(){\n      if (self.iframe.readyState == 'complete') {\n        complete();\n      }\n    };\n  } else {\n    this.iframe.onload = complete;\n  }\n};\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./polling\":18,\"component-inherit\":21}],17:[function(_dereq_,module,exports){\n(function (global){\n/**\n * Module requirements.\n */\n\nvar XMLHttpRequest = _dereq_('xmlhttprequest');\nvar Polling = _dereq_('./polling');\nvar Emitter = _dereq_('component-emitter');\nvar inherit = _dereq_('component-inherit');\nvar debug = _dereq_('debug')('engine.io-client:polling-xhr');\n\n/**\n * Module exports.\n */\n\nmodule.exports = XHR;\nmodule.exports.Request = Request;\n\n/**\n * Empty function\n */\n\nfunction empty(){}\n\n/**\n * XHR Polling constructor.\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction XHR(opts){\n  Polling.call(this, opts);\n\n  if (global.location) {\n    var isSSL = 'https:' == location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    this.xd = opts.hostname != global.location.hostname ||\n      port != opts.port;\n    this.xs = opts.secure != isSSL;\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(XHR, Polling);\n\n/**\n * XHR supports binary\n */\n\nXHR.prototype.supportsBinary = true;\n\n/**\n * Creates a request.\n *\n * @param {String} method\n * @api private\n */\n\nXHR.prototype.request = function(opts){\n  opts = opts || {};\n  opts.uri = this.uri();\n  opts.xd = this.xd;\n  opts.xs = this.xs;\n  opts.agent = this.agent || false;\n  opts.supportsBinary = this.supportsBinary;\n  opts.enablesXDR = this.enablesXDR;\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  return new Request(opts);\n};\n\n/**\n * Sends data.\n *\n * @param {String} data to send.\n * @param {Function} called upon flush.\n * @api private\n */\n\nXHR.prototype.doWrite = function(data, fn){\n  var isBinary = typeof data !== 'string' && data !== undefined;\n  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });\n  var self = this;\n  req.on('success', fn);\n  req.on('error', function(err){\n    self.onError('xhr post error', err);\n  });\n  this.sendXhr = req;\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nXHR.prototype.doPoll = function(){\n  debug('xhr poll');\n  var req = this.request();\n  var self = this;\n  req.on('data', function(data){\n    self.onData(data);\n  });\n  req.on('error', function(err){\n    self.onError('xhr poll error', err);\n  });\n  this.pollXhr = req;\n};\n\n/**\n * Request constructor\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Request(opts){\n  this.method = opts.method || 'GET';\n  this.uri = opts.uri;\n  this.xd = !!opts.xd;\n  this.xs = !!opts.xs;\n  this.async = false !== opts.async;\n  this.data = undefined != opts.data ? opts.data : null;\n  this.agent = opts.agent;\n  this.isBinary = opts.isBinary;\n  this.supportsBinary = opts.supportsBinary;\n  this.enablesXDR = opts.enablesXDR;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n\n  this.create();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Creates the XHR object and sends the request.\n *\n * @api private\n */\n\nRequest.prototype.create = function(){\n  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  var xhr = this.xhr = new XMLHttpRequest(opts);\n  var self = this;\n\n  try {\n    debug('xhr open %s: %s', this.method, this.uri);\n    xhr.open(this.method, this.uri, this.async);\n    if (this.supportsBinary) {\n      // This has to be done after open because Firefox is stupid\n      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension\n      xhr.responseType = 'arraybuffer';\n    }\n\n    if ('POST' == this.method) {\n      try {\n        if (this.isBinary) {\n          xhr.setRequestHeader('Content-type', 'application/octet-stream');\n        } else {\n          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n        }\n      } catch (e) {}\n    }\n\n    // ie6 check\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    if (this.hasXDR()) {\n      xhr.onload = function(){\n        self.onLoad();\n      };\n      xhr.onerror = function(){\n        self.onError(xhr.responseText);\n      };\n    } else {\n      xhr.onreadystatechange = function(){\n        if (4 != xhr.readyState) return;\n        if (200 == xhr.status || 1223 == xhr.status) {\n          self.onLoad();\n        } else {\n          // make sure the `error` event handler that's user-set\n          // does not throw in the same tick and gets caught here\n          setTimeout(function(){\n            self.onError(xhr.status);\n          }, 0);\n        }\n      };\n    }\n\n    debug('xhr data %s', this.data);\n    xhr.send(this.data);\n  } catch (e) {\n    // Need to defer since .create() is called directly fhrom the constructor\n    // and thus the 'error' event can only be only bound *after* this exception\n    // occurs.  Therefore, also, we cannot throw here at all.\n    setTimeout(function() {\n      self.onError(e);\n    }, 0);\n    return;\n  }\n\n  if (global.document) {\n    this.index = Request.requestsCount++;\n    Request.requests[this.index] = this;\n  }\n};\n\n/**\n * Called upon successful response.\n *\n * @api private\n */\n\nRequest.prototype.onSuccess = function(){\n  this.emit('success');\n  this.cleanup();\n};\n\n/**\n * Called if we have data.\n *\n * @api private\n */\n\nRequest.prototype.onData = function(data){\n  this.emit('data', data);\n  this.onSuccess();\n};\n\n/**\n * Called upon error.\n *\n * @api private\n */\n\nRequest.prototype.onError = function(err){\n  this.emit('error', err);\n  this.cleanup(true);\n};\n\n/**\n * Cleans up house.\n *\n * @api private\n */\n\nRequest.prototype.cleanup = function(fromError){\n  if ('undefined' == typeof this.xhr || null === this.xhr) {\n    return;\n  }\n  // xmlhttprequest\n  if (this.hasXDR()) {\n    this.xhr.onload = this.xhr.onerror = empty;\n  } else {\n    this.xhr.onreadystatechange = empty;\n  }\n\n  if (fromError) {\n    try {\n      this.xhr.abort();\n    } catch(e) {}\n  }\n\n  if (global.document) {\n    delete Request.requests[this.index];\n  }\n\n  this.xhr = null;\n};\n\n/**\n * Called upon load.\n *\n * @api private\n */\n\nRequest.prototype.onLoad = function(){\n  var data;\n  try {\n    var contentType;\n    try {\n      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];\n    } catch (e) {}\n    if (contentType === 'application/octet-stream') {\n      data = this.xhr.response;\n    } else {\n      if (!this.supportsBinary) {\n        data = this.xhr.responseText;\n      } else {\n        data = 'ok';\n      }\n    }\n  } catch (e) {\n    this.onError(e);\n  }\n  if (null != data) {\n    this.onData(data);\n  }\n};\n\n/**\n * Check if it has XDomainRequest.\n *\n * @api private\n */\n\nRequest.prototype.hasXDR = function(){\n  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;\n};\n\n/**\n * Aborts the request.\n *\n * @api public\n */\n\nRequest.prototype.abort = function(){\n  this.cleanup();\n};\n\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\n\nif (global.document) {\n  Request.requestsCount = 0;\n  Request.requests = {};\n  if (global.attachEvent) {\n    global.attachEvent('onunload', unloadHandler);\n  } else if (global.addEventListener) {\n    global.addEventListener('beforeunload', unloadHandler, false);\n  }\n}\n\nfunction unloadHandler() {\n  for (var i in Request.requests) {\n    if (Request.requests.hasOwnProperty(i)) {\n      Request.requests[i].abort();\n    }\n  }\n}\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./polling\":18,\"component-emitter\":9,\"component-inherit\":21,\"debug\":22,\"xmlhttprequest\":20}],18:[function(_dereq_,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Transport = _dereq_('../transport');\nvar parseqs = _dereq_('parseqs');\nvar parser = _dereq_('engine.io-parser');\nvar inherit = _dereq_('component-inherit');\nvar debug = _dereq_('debug')('engine.io-client:polling');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Polling;\n\n/**\n * Is XHR2 supported?\n */\n\nvar hasXHR2 = (function() {\n  var XMLHttpRequest = _dereq_('xmlhttprequest');\n  var xhr = new XMLHttpRequest({ xdomain: false });\n  return null != xhr.responseType;\n})();\n\n/**\n * Polling interface.\n *\n * @param {Object} opts\n * @api private\n */\n\nfunction Polling(opts){\n  var forceBase64 = (opts && opts.forceBase64);\n  if (!hasXHR2 || forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(Polling, Transport);\n\n/**\n * Transport name.\n */\n\nPolling.prototype.name = 'polling';\n\n/**\n * Opens the socket (triggers polling). We write a PING message to determine\n * when the transport is open.\n *\n * @api private\n */\n\nPolling.prototype.doOpen = function(){\n  this.poll();\n};\n\n/**\n * Pauses polling.\n *\n * @param {Function} callback upon buffers are flushed and transport is paused\n * @api private\n */\n\nPolling.prototype.pause = function(onPause){\n  var pending = 0;\n  var self = this;\n\n  this.readyState = 'pausing';\n\n  function pause(){\n    debug('paused');\n    self.readyState = 'paused';\n    onPause();\n  }\n\n  if (this.polling || !this.writable) {\n    var total = 0;\n\n    if (this.polling) {\n      debug('we are currently polling - waiting to pause');\n      total++;\n      this.once('pollComplete', function(){\n        debug('pre-pause polling complete');\n        --total || pause();\n      });\n    }\n\n    if (!this.writable) {\n      debug('we are currently writing - waiting to pause');\n      total++;\n      this.once('drain', function(){\n        debug('pre-pause writing complete');\n        --total || pause();\n      });\n    }\n  } else {\n    pause();\n  }\n};\n\n/**\n * Starts polling cycle.\n *\n * @api public\n */\n\nPolling.prototype.poll = function(){\n  debug('polling');\n  this.polling = true;\n  this.doPoll();\n  this.emit('poll');\n};\n\n/**\n * Overloads onData to detect payloads.\n *\n * @api private\n */\n\nPolling.prototype.onData = function(data){\n  var self = this;\n  debug('polling got data %s', data);\n  var callback = function(packet, index, total) {\n    // if its the first message we consider the transport open\n    if ('opening' == self.readyState) {\n      self.onOpen();\n    }\n\n    // if its a close packet, we close the ongoing requests\n    if ('close' == packet.type) {\n      self.onClose();\n      return false;\n    }\n\n    // otherwise bypass onData and handle the message\n    self.onPacket(packet);\n  };\n\n  // decode payload\n  parser.decodePayload(data, this.socket.binaryType, callback);\n\n  // if an event did not trigger closing\n  if ('closed' != this.readyState) {\n    // if we got data we're not polling\n    this.polling = false;\n    this.emit('pollComplete');\n\n    if ('open' == this.readyState) {\n      this.poll();\n    } else {\n      debug('ignoring poll - transport state \"%s\"', this.readyState);\n    }\n  }\n};\n\n/**\n * For polling, send a close packet.\n *\n * @api private\n */\n\nPolling.prototype.doClose = function(){\n  var self = this;\n\n  function close(){\n    debug('writing close packet');\n    self.write([{ type: 'close' }]);\n  }\n\n  if ('open' == this.readyState) {\n    debug('transport open - closing');\n    close();\n  } else {\n    // in case we're trying to close while\n    // handshaking is in progress (GH-164)\n    debug('transport not open - deferring close');\n    this.once('open', close);\n  }\n};\n\n/**\n * Writes a packets payload.\n *\n * @param {Array} data packets\n * @param {Function} drain callback\n * @api private\n */\n\nPolling.prototype.write = function(packets){\n  var self = this;\n  this.writable = false;\n  var callbackfn = function() {\n    self.writable = true;\n    self.emit('drain');\n  };\n\n  var self = this;\n  parser.encodePayload(packets, this.supportsBinary, function(data) {\n    self.doWrite(data, callbackfn);\n  });\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nPolling.prototype.uri = function(){\n  var query = this.query || {};\n  var schema = this.secure ? 'https' : 'http';\n  var port = '';\n\n  // cache busting is forced\n  if (false !== this.timestampRequests) {\n    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;\n  }\n\n  if (!this.supportsBinary && !query.sid) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // avoid port if default for schema\n  if (this.port && (('https' == schema && this.port != 443) ||\n     ('http' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  return schema + '://' + this.hostname + port + this.path + query;\n};\n\n},{\"../transport\":14,\"component-inherit\":21,\"debug\":22,\"engine.io-parser\":25,\"parseqs\":33,\"xmlhttprequest\":20}],19:[function(_dereq_,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Transport = _dereq_('../transport');\nvar parser = _dereq_('engine.io-parser');\nvar parseqs = _dereq_('parseqs');\nvar inherit = _dereq_('component-inherit');\nvar debug = _dereq_('debug')('engine.io-client:websocket');\n\n/**\n * `ws` exposes a WebSocket-compatible interface in\n * Node, or the `WebSocket` or `MozWebSocket` globals\n * in the browser.\n */\n\nvar WebSocket = _dereq_('ws');\n\n/**\n * Module exports.\n */\n\nmodule.exports = WS;\n\n/**\n * WebSocket transport constructor.\n *\n * @api {Object} connection options\n * @api public\n */\n\nfunction WS(opts){\n  var forceBase64 = (opts && opts.forceBase64);\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(WS, Transport);\n\n/**\n * Transport name.\n *\n * @api public\n */\n\nWS.prototype.name = 'websocket';\n\n/*\n * WebSockets support binary\n */\n\nWS.prototype.supportsBinary = true;\n\n/**\n * Opens socket.\n *\n * @api private\n */\n\nWS.prototype.doOpen = function(){\n  if (!this.check()) {\n    // let probe timeout\n    return;\n  }\n\n  var self = this;\n  var uri = this.uri();\n  var protocols = void(0);\n  var opts = { agent: this.agent };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  this.ws = new WebSocket(uri, protocols, opts);\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  this.ws.binaryType = 'arraybuffer';\n  this.addEventListeners();\n};\n\n/**\n * Adds event listeners to the socket\n *\n * @api private\n */\n\nWS.prototype.addEventListeners = function(){\n  var self = this;\n\n  this.ws.onopen = function(){\n    self.onOpen();\n  };\n  this.ws.onclose = function(){\n    self.onClose();\n  };\n  this.ws.onmessage = function(ev){\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function(e){\n    self.onError('websocket error', e);\n  };\n};\n\n/**\n * Override `onData` to use a timer on iOS.\n * See: https://gist.github.com/mloughran/2052006\n *\n * @api private\n */\n\nif ('undefined' != typeof navigator\n  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {\n  WS.prototype.onData = function(data){\n    var self = this;\n    setTimeout(function(){\n      Transport.prototype.onData.call(self, data);\n    }, 0);\n  };\n}\n\n/**\n * Writes data to socket.\n *\n * @param {Array} array of packets.\n * @api private\n */\n\nWS.prototype.write = function(packets){\n  var self = this;\n  this.writable = false;\n  // encodePacket efficient as it uses WS framing\n  // no need for encodePayload\n  for (var i = 0, l = packets.length; i < l; i++) {\n    parser.encodePacket(packets[i], this.supportsBinary, function(data) {\n      //Sometimes the websocket has already been closed but the browser didn't\n      //have a chance of informing us about it yet, in that case send will\n      //throw an error\n      try {\n        self.ws.send(data);\n      } catch (e){\n        debug('websocket closed before onclose event');\n      }\n    });\n  }\n\n  function ondrain() {\n    self.writable = true;\n    self.emit('drain');\n  }\n  // fake drain\n  // defer to next tick to allow Socket to clear writeBuffer\n  setTimeout(ondrain, 0);\n};\n\n/**\n * Called upon close\n *\n * @api private\n */\n\nWS.prototype.onClose = function(){\n  Transport.prototype.onClose.call(this);\n};\n\n/**\n * Closes socket.\n *\n * @api private\n */\n\nWS.prototype.doClose = function(){\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nWS.prototype.uri = function(){\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  // avoid port if default for schema\n  if (this.port && (('wss' == schema && this.port != 443)\n    || ('ws' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  // append timestamp to URI\n  if (this.timestampRequests) {\n    query[this.timestampParam] = +new Date;\n  }\n\n  // communicate binary support capabilities\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  return schema + '://' + this.hostname + port + this.path + query;\n};\n\n/**\n * Feature detection for WebSocket.\n *\n * @return {Boolean} whether this transport is available.\n * @api public\n */\n\nWS.prototype.check = function(){\n  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n};\n\n},{\"../transport\":14,\"component-inherit\":21,\"debug\":22,\"engine.io-parser\":25,\"parseqs\":33,\"ws\":35}],20:[function(_dereq_,module,exports){\n// browser shim for xmlhttprequest module\nvar hasCORS = _dereq_('has-cors');\n\nmodule.exports = function(opts) {\n  var xdomain = opts.xdomain;\n\n  // scheme must be same when usign XDomainRequest\n  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n  var xscheme = opts.xscheme;\n\n  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.\n  // https://github.com/Automattic/engine.io-client/pull/217\n  var enablesXDR = opts.enablesXDR;\n\n  // XMLHttpRequest can be disabled on IE\n  try {\n    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n      return new XMLHttpRequest();\n    }\n  } catch (e) { }\n\n  // Use XDomainRequest for IE8 if enablesXDR is true\n  // because loading bar keeps flashing when using jsonp-polling\n  // https://github.com/yujiosaka/socke.io-ie8-loading-example\n  try {\n    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {\n      return new XDomainRequest();\n    }\n  } catch (e) { }\n\n  if (!xdomain) {\n    try {\n      return new ActiveXObject('Microsoft.XMLHTTP');\n    } catch(e) { }\n  }\n}\n\n},{\"has-cors\":38}],21:[function(_dereq_,module,exports){\n\nmodule.exports = function(a, b){\n  var fn = function(){};\n  fn.prototype = b.prototype;\n  a.prototype = new fn;\n  a.prototype.constructor = a;\n};\n},{}],22:[function(_dereq_,module,exports){\n\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = _dereq_('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // This hackery is required for IE8,\n  // where the `console.log` function doesn't have 'apply'\n  return 'object' == typeof console\n    && 'function' == typeof console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      localStorage.removeItem('debug');\n    } else {\n      localStorage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = localStorage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n},{\"./debug\":23}],23:[function(_dereq_,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = _dereq_('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n},{\"ms\":24}],24:[function(_dereq_,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  var match = /^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}],25:[function(_dereq_,module,exports){\n(function (global){\n/**\n * Module dependencies.\n */\n\nvar keys = _dereq_('./keys');\nvar hasBinary = _dereq_('has-binary');\nvar sliceBuffer = _dereq_('arraybuffer.slice');\nvar base64encoder = _dereq_('base64-arraybuffer');\nvar after = _dereq_('after');\nvar utf8 = _dereq_('utf8');\n\n/**\n * Check if we are running an android browser. That requires us to use\n * ArrayBuffer with polling transports...\n *\n * http://ghinda.net/jpeg-blob-ajax-android/\n */\n\nvar isAndroid = navigator.userAgent.match(/Android/i);\n\n/**\n * Check if we are running in PhantomJS.\n * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n * https://github.com/ariya/phantomjs/issues/11395\n * @type boolean\n */\nvar isPhantomJS = /PhantomJS/i.test(navigator.userAgent);\n\n/**\n * When true, avoids using Blobs to encode payloads.\n * @type boolean\n */\nvar dontSendBlobs = isAndroid || isPhantomJS;\n\n/**\n * Current protocol version.\n */\n\nexports.protocol = 3;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\n/**\n * Create a blob api even for blob builder when vendor prefixes exist\n */\n\nvar Blob = _dereq_('blob');\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if ('function' == typeof supportsBinary) {\n    callback = supportsBinary;\n    supportsBinary = false;\n  }\n\n  if ('function' == typeof utf8encode) {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  var data = (packet.data === undefined)\n    ? undefined\n    : packet.data.buffer || packet.data;\n\n  if (global.ArrayBuffer && data instanceof ArrayBuffer) {\n    return encodeArrayBuffer(packet, supportsBinary, callback);\n  } else if (Blob && data instanceof global.Blob) {\n    return encodeBlob(packet, supportsBinary, callback);\n  }\n\n  // might be an object with { base64: true, data: dataAsBase64String }\n  if (data && data.base64) {\n    return encodeBase64Object(packet, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n\n};\n\nfunction encodeBase64Object(packet, callback) {\n  // packet data is an object { base64: true, data: dataAsBase64String }\n  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n  return callback(message);\n}\n\n/**\n * Encode packet helpers for binary types\n */\n\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var contentArray = new Uint8Array(data);\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\n\n  resultBuffer[0] = packets[packet.type];\n  for (var i = 0; i < contentArray.length; i++) {\n    resultBuffer[i+1] = contentArray[i];\n  }\n\n  return callback(resultBuffer.buffer);\n}\n\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var fr = new FileReader();\n  fr.onload = function() {\n    packet.data = fr.result;\n    exports.encodePacket(packet, supportsBinary, true, callback);\n  };\n  return fr.readAsArrayBuffer(packet.data);\n}\n\nfunction encodeBlob(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  if (dontSendBlobs) {\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n  }\n\n  var length = new Uint8Array(1);\n  length[0] = packets[packet.type];\n  var blob = new Blob([length.buffer, packet.data]);\n\n  return callback(blob);\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function(packet, callback) {\n  var message = 'b' + exports.packets[packet.type];\n  if (Blob && packet.data instanceof Blob) {\n    var fr = new FileReader();\n    fr.onload = function() {\n      var b64 = fr.result.split(',')[1];\n      callback(message + b64);\n    };\n    return fr.readAsDataURL(packet.data);\n  }\n\n  var b64data;\n  try {\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n  } catch (e) {\n    // iPhone Safari doesn't let you apply with typed arrays\n    var typed = new Uint8Array(packet.data);\n    var basic = new Array(typed.length);\n    for (var i = 0; i < typed.length; i++) {\n      basic[i] = typed[i];\n    }\n    b64data = String.fromCharCode.apply(null, basic);\n  }\n  message += global.btoa(b64data);\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Changes format to Blob if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  // String data\n  if (typeof data == 'string' || data === undefined) {\n    if (data.charAt(0) == 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      try {\n        data = utf8.decode(data);\n      } catch (e) {\n        return err;\n      }\n    }\n    var type = data.charAt(0);\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return { type: packetslist[type], data: data.substring(1) };\n    } else {\n      return { type: packetslist[type] };\n    }\n  }\n\n  var asArray = new Uint8Array(data);\n  var type = asArray[0];\n  var rest = sliceBuffer(data, 1);\n  if (Blob && binaryType === 'blob') {\n    rest = new Blob([rest]);\n  }\n  return { type: packetslist[type], data: rest };\n};\n\n/**\n * Decodes a packet encoded in a base64 string\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  if (!global.ArrayBuffer) {\n    return { type: type, data: { base64: true, data: msg.substr(1) } };\n  }\n\n  var data = base64encoder.decode(msg.substr(1));\n\n  if (binaryType === 'blob' && Blob) {\n    data = new Blob([data]);\n  }\n\n  return { type: type, data: data };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary == 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  var isBinary = hasBinary(packets);\n\n  if (supportsBinary && isBinary) {\n    if (Blob && !dontSendBlobs) {\n      return exports.encodePayloadAsBlob(packets, callback);\n    }\n\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function setLengthHeader(message) {\n    return message.length + ':' + message;\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(results.join(''));\n  });\n};\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n\n  var eachWithIndex = function(i, el, cb) {\n    each(el, function(error, msg) {\n      result[i] = msg;\n      cb(error, result);\n    });\n  };\n\n  for (var i = 0; i < ary.length; i++) {\n    eachWithIndex(i, ary[i], next);\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data != 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var packet;\n  if (data == '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = ''\n    , n, msg;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (':' != chr) {\n      length += chr;\n    } else {\n      if ('' == length || (length != (n = Number(length)))) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      msg = data.substr(i + 1, n);\n\n      if (length != msg.length) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      if (msg.length) {\n        packet = exports.decodePacket(msg, binaryType, true);\n\n        if (err.type == packet.type && err.data == packet.data) {\n          // parser error in individual packet - ignoring payload\n          return callback(err, 0, 1);\n        }\n\n        var ret = callback(packet, i + n, l);\n        if (false === ret) return;\n      }\n\n      // advance cursor\n      i += n;\n      length = '';\n    }\n  }\n\n  if (length != '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {ArrayBuffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsArrayBuffer = function(packets, callback) {\n  if (!packets.length) {\n    return callback(new ArrayBuffer(0));\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(data) {\n      return doneCallback(null, data);\n    });\n  }\n\n  map(packets, encodeOne, function(err, encodedPackets) {\n    var totalLength = encodedPackets.reduce(function(acc, p) {\n      var len;\n      if (typeof p === 'string'){\n        len = p.length;\n      } else {\n        len = p.byteLength;\n      }\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n    }, 0);\n\n    var resultArray = new Uint8Array(totalLength);\n\n    var bufferIndex = 0;\n    encodedPackets.forEach(function(p) {\n      var isString = typeof p === 'string';\n      var ab = p;\n      if (isString) {\n        var view = new Uint8Array(p.length);\n        for (var i = 0; i < p.length; i++) {\n          view[i] = p.charCodeAt(i);\n        }\n        ab = view.buffer;\n      }\n\n      if (isString) { // not true binary\n        resultArray[bufferIndex++] = 0;\n      } else { // true binary\n        resultArray[bufferIndex++] = 1;\n      }\n\n      var lenStr = ab.byteLength.toString();\n      for (var i = 0; i < lenStr.length; i++) {\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n      }\n      resultArray[bufferIndex++] = 255;\n\n      var view = new Uint8Array(ab);\n      for (var i = 0; i < view.length; i++) {\n        resultArray[bufferIndex++] = view[i];\n      }\n    });\n\n    return callback(resultArray.buffer);\n  });\n};\n\n/**\n * Encode as Blob\n */\n\nexports.encodePayloadAsBlob = function(packets, callback) {\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(encoded) {\n      var binaryIdentifier = new Uint8Array(1);\n      binaryIdentifier[0] = 1;\n      if (typeof encoded === 'string') {\n        var view = new Uint8Array(encoded.length);\n        for (var i = 0; i < encoded.length; i++) {\n          view[i] = encoded.charCodeAt(i);\n        }\n        encoded = view.buffer;\n        binaryIdentifier[0] = 0;\n      }\n\n      var len = (encoded instanceof ArrayBuffer)\n        ? encoded.byteLength\n        : encoded.size;\n\n      var lenStr = len.toString();\n      var lengthAry = new Uint8Array(lenStr.length + 1);\n      for (var i = 0; i < lenStr.length; i++) {\n        lengthAry[i] = parseInt(lenStr[i]);\n      }\n      lengthAry[lenStr.length] = 255;\n\n      if (Blob) {\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n        doneCallback(null, blob);\n      }\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(new Blob(results));\n  });\n};\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n *\n * @param {ArrayBuffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n\n  var numberTooLong = false;\n  while (bufferTail.byteLength > 0) {\n    var tailArray = new Uint8Array(bufferTail);\n    var isString = tailArray[0] === 0;\n    var msgLength = '';\n\n    for (var i = 1; ; i++) {\n      if (tailArray[i] == 255) break;\n\n      if (msgLength.length > 310) {\n        numberTooLong = true;\n        break;\n      }\n\n      msgLength += tailArray[i];\n    }\n\n    if(numberTooLong) return callback(err, 0, 1);\n\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n    msgLength = parseInt(msgLength);\n\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\n    if (isString) {\n      try {\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n      } catch (e) {\n        // iPhone Safari doesn't let you apply to typed arrays\n        var typed = new Uint8Array(msg);\n        msg = '';\n        for (var i = 0; i < typed.length; i++) {\n          msg += String.fromCharCode(typed[i]);\n        }\n      }\n    }\n\n    buffers.push(msg);\n    bufferTail = sliceBuffer(bufferTail, msgLength);\n  }\n\n  var total = buffers.length;\n  buffers.forEach(function(buffer, i) {\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  });\n};\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./keys\":26,\"after\":27,\"arraybuffer.slice\":28,\"base64-arraybuffer\":29,\"blob\":30,\"has-binary\":36,\"utf8\":31}],26:[function(_dereq_,module,exports){\n\n/**\n * Gets the keys for an object.\n *\n * @return {Array} keys\n * @api private\n */\n\nmodule.exports = Object.keys || function keys (obj){\n  var arr = [];\n  var has = Object.prototype.hasOwnProperty;\n\n  for (var i in obj) {\n    if (has.call(obj, i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n},{}],27:[function(_dereq_,module,exports){\nmodule.exports = after\n\nfunction after(count, callback, err_cb) {\n    var bail = false\n    err_cb = err_cb || noop\n    proxy.count = count\n\n    return (count === 0) ? callback() : proxy\n\n    function proxy(err, result) {\n        if (proxy.count <= 0) {\n            throw new Error('after called too many times')\n        }\n        --proxy.count\n\n        // after first error, rest are passed to err_cb\n        if (err) {\n            bail = true\n            callback(err)\n            // future error callbacks will go to error handler\n            callback = err_cb\n        } else if (proxy.count === 0 && !bail) {\n            callback(null, result)\n        }\n    }\n}\n\nfunction noop() {}\n\n},{}],28:[function(_dereq_,module,exports){\n/**\n * An abstraction for slicing an arraybuffer even when\n * ArrayBuffer.prototype.slice is not supported\n *\n * @api public\n */\n\nmodule.exports = function(arraybuffer, start, end) {\n  var bytes = arraybuffer.byteLength;\n  start = start || 0;\n  end = end || bytes;\n\n  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }\n\n  if (start < 0) { start += bytes; }\n  if (end < 0) { end += bytes; }\n  if (end > bytes) { end = bytes; }\n\n  if (start >= bytes || start >= end || bytes === 0) {\n    return new ArrayBuffer(0);\n  }\n\n  var abv = new Uint8Array(arraybuffer);\n  var result = new Uint8Array(end - start);\n  for (var i = start, ii = 0; i < end; i++, ii++) {\n    result[ii] = abv[i];\n  }\n  return result.buffer;\n};\n\n},{}],29:[function(_dereq_,module,exports){\n/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function(chars){\n  \"use strict\";\n\n  exports.encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer),\n    i, len = bytes.length, base64 = \"\";\n\n    for (i = 0; i < len; i+=3) {\n      base64 += chars[bytes[i] >> 2];\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n      base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n      base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n\n    return base64;\n  };\n\n  exports.decode =  function(base64) {\n    var bufferLength = base64.length * 0.75,\n    len = base64.length, i, p = 0,\n    encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === \"=\") {\n      bufferLength--;\n      if (base64[base64.length - 2] === \"=\") {\n        bufferLength--;\n      }\n    }\n\n    var arraybuffer = new ArrayBuffer(bufferLength),\n    bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i+=4) {\n      encoded1 = chars.indexOf(base64[i]);\n      encoded2 = chars.indexOf(base64[i+1]);\n      encoded3 = chars.indexOf(base64[i+2]);\n      encoded4 = chars.indexOf(base64[i+3]);\n\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n  };\n})(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\");\n\n},{}],30:[function(_dereq_,module,exports){\n(function (global){\n/**\n * Create a blob builder even when vendor prefixes exist\n */\n\nvar BlobBuilder = global.BlobBuilder\n  || global.WebKitBlobBuilder\n  || global.MSBlobBuilder\n  || global.MozBlobBuilder;\n\n/**\n * Check if Blob constructor is supported\n */\n\nvar blobSupported = (function() {\n  try {\n    var a = new Blob(['hi']);\n    return a.size === 2;\n  } catch(e) {\n    return false;\n  }\n})();\n\n/**\n * Check if Blob constructor supports ArrayBufferViews\n * Fails in Safari 6, so we need to map to ArrayBuffers there.\n */\n\nvar blobSupportsArrayBufferView = blobSupported && (function() {\n  try {\n    var b = new Blob([new Uint8Array([1,2])]);\n    return b.size === 2;\n  } catch(e) {\n    return false;\n  }\n})();\n\n/**\n * Check if BlobBuilder is supported\n */\n\nvar blobBuilderSupported = BlobBuilder\n  && BlobBuilder.prototype.append\n  && BlobBuilder.prototype.getBlob;\n\n/**\n * Helper function that maps ArrayBufferViews to ArrayBuffers\n * Used by BlobBuilder constructor and old browsers that didn't\n * support it in the Blob constructor.\n */\n\nfunction mapArrayBufferViews(ary) {\n  for (var i = 0; i < ary.length; i++) {\n    var chunk = ary[i];\n    if (chunk.buffer instanceof ArrayBuffer) {\n      var buf = chunk.buffer;\n\n      // if this is a subarray, make a copy so we only\n      // include the subarray region from the underlying buffer\n      if (chunk.byteLength !== buf.byteLength) {\n        var copy = new Uint8Array(chunk.byteLength);\n        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\n        buf = copy.buffer;\n      }\n\n      ary[i] = buf;\n    }\n  }\n}\n\nfunction BlobBuilderConstructor(ary, options) {\n  options = options || {};\n\n  var bb = new BlobBuilder();\n  mapArrayBufferViews(ary);\n\n  for (var i = 0; i < ary.length; i++) {\n    bb.append(ary[i]);\n  }\n\n  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();\n};\n\nfunction BlobConstructor(ary, options) {\n  mapArrayBufferViews(ary);\n  return new Blob(ary, options || {});\n};\n\nmodule.exports = (function() {\n  if (blobSupported) {\n    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;\n  } else if (blobBuilderSupported) {\n    return BlobBuilderConstructor;\n  } else {\n    return undefined;\n  }\n})();\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],31:[function(_dereq_,module,exports){\n(function (global){\n/*! https://mths.be/utf8js v2.0.0 by @mathias */\n;(function(root) {\n\n  // Detect free variables `exports`\n  var freeExports = typeof exports == 'object' && exports;\n\n  // Detect free variable `module`\n  var freeModule = typeof module == 'object' && module &&\n    module.exports == freeExports && module;\n\n  // Detect free variable `global`, from Node.js or Browserified code,\n  // and use it as `root`\n  var freeGlobal = typeof global == 'object' && global;\n  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n    root = freeGlobal;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  var stringFromCharCode = String.fromCharCode;\n\n  // Taken from https://mths.be/punycode\n  function ucs2decode(string) {\n    var output = [];\n    var counter = 0;\n    var length = string.length;\n    var value;\n    var extra;\n    while (counter < length) {\n      value = string.charCodeAt(counter++);\n      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n        // high surrogate, and there is a next character\n        extra = string.charCodeAt(counter++);\n        if ((extra & 0xFC00) == 0xDC00) { // low surrogate\n          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n        } else {\n          // unmatched surrogate; only append this code unit, in case the next\n          // code unit is the high surrogate of a surrogate pair\n          output.push(value);\n          counter--;\n        }\n      } else {\n        output.push(value);\n      }\n    }\n    return output;\n  }\n\n  // Taken from https://mths.be/punycode\n  function ucs2encode(array) {\n    var length = array.length;\n    var index = -1;\n    var value;\n    var output = '';\n    while (++index < length) {\n      value = array[index];\n      if (value > 0xFFFF) {\n        value -= 0x10000;\n        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n        value = 0xDC00 | value & 0x3FF;\n      }\n      output += stringFromCharCode(value);\n    }\n    return output;\n  }\n\n  function checkScalarValue(codePoint) {\n    if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n      throw Error(\n        'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n        ' is not a scalar value'\n      );\n    }\n  }\n  /*--------------------------------------------------------------------------*/\n\n  function createByte(codePoint, shift) {\n    return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n  }\n\n  function encodeCodePoint(codePoint) {\n    if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n      return stringFromCharCode(codePoint);\n    }\n    var symbol = '';\n    if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n      symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n    }\n    else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n      checkScalarValue(codePoint);\n      symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n      symbol += createByte(codePoint, 6);\n    }\n    else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n      symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n      symbol += createByte(codePoint, 12);\n      symbol += createByte(codePoint, 6);\n    }\n    symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n    return symbol;\n  }\n\n  function utf8encode(string) {\n    var codePoints = ucs2decode(string);\n    var length = codePoints.length;\n    var index = -1;\n    var codePoint;\n    var byteString = '';\n    while (++index < length) {\n      codePoint = codePoints[index];\n      byteString += encodeCodePoint(codePoint);\n    }\n    return byteString;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  function readContinuationByte() {\n    if (byteIndex >= byteCount) {\n      throw Error('Invalid byte index');\n    }\n\n    var continuationByte = byteArray[byteIndex] & 0xFF;\n    byteIndex++;\n\n    if ((continuationByte & 0xC0) == 0x80) {\n      return continuationByte & 0x3F;\n    }\n\n    // If we end up here, it’s not a continuation byte\n    throw Error('Invalid continuation byte');\n  }\n\n  function decodeSymbol() {\n    var byte1;\n    var byte2;\n    var byte3;\n    var byte4;\n    var codePoint;\n\n    if (byteIndex > byteCount) {\n      throw Error('Invalid byte index');\n    }\n\n    if (byteIndex == byteCount) {\n      return false;\n    }\n\n    // Read first byte\n    byte1 = byteArray[byteIndex] & 0xFF;\n    byteIndex++;\n\n    // 1-byte sequence (no continuation bytes)\n    if ((byte1 & 0x80) == 0) {\n      return byte1;\n    }\n\n    // 2-byte sequence\n    if ((byte1 & 0xE0) == 0xC0) {\n      var byte2 = readContinuationByte();\n      codePoint = ((byte1 & 0x1F) << 6) | byte2;\n      if (codePoint >= 0x80) {\n        return codePoint;\n      } else {\n        throw Error('Invalid continuation byte');\n      }\n    }\n\n    // 3-byte sequence (may include unpaired surrogates)\n    if ((byte1 & 0xF0) == 0xE0) {\n      byte2 = readContinuationByte();\n      byte3 = readContinuationByte();\n      codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n      if (codePoint >= 0x0800) {\n        checkScalarValue(codePoint);\n        return codePoint;\n      } else {\n        throw Error('Invalid continuation byte');\n      }\n    }\n\n    // 4-byte sequence\n    if ((byte1 & 0xF8) == 0xF0) {\n      byte2 = readContinuationByte();\n      byte3 = readContinuationByte();\n      byte4 = readContinuationByte();\n      codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |\n        (byte3 << 0x06) | byte4;\n      if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n        return codePoint;\n      }\n    }\n\n    throw Error('Invalid UTF-8 detected');\n  }\n\n  var byteArray;\n  var byteCount;\n  var byteIndex;\n  function utf8decode(byteString) {\n    byteArray = ucs2decode(byteString);\n    byteCount = byteArray.length;\n    byteIndex = 0;\n    var codePoints = [];\n    var tmp;\n    while ((tmp = decodeSymbol()) !== false) {\n      codePoints.push(tmp);\n    }\n    return ucs2encode(codePoints);\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  var utf8 = {\n    'version': '2.0.0',\n    'encode': utf8encode,\n    'decode': utf8decode\n  };\n\n  // Some AMD build optimizers, like r.js, check for specific condition patterns\n  // like the following:\n  if (\n    typeof define == 'function' &&\n    typeof define.amd == 'object' &&\n    define.amd\n  ) {\n    define(function() {\n      return utf8;\n    });\n  } else if (freeExports && !freeExports.nodeType) {\n    if (freeModule) { // in Node.js or RingoJS v0.8.0+\n      freeModule.exports = utf8;\n    } else { // in Narwhal or RingoJS v0.7.0-\n      var object = {};\n      var hasOwnProperty = object.hasOwnProperty;\n      for (var key in utf8) {\n        hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);\n      }\n    }\n  } else { // in Rhino or a web browser\n    root.utf8 = utf8;\n  }\n\n}(this));\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],32:[function(_dereq_,module,exports){\n(function (global){\n/**\n * JSON parse.\n *\n * @see Based on jQuery#parseJSON (MIT) and JSON2\n * @api private\n */\n\nvar rvalidchars = /^[\\],:{}\\s]*$/;\nvar rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\nvar rvalidtokens = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nvar rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g;\nvar rtrimLeft = /^\\s+/;\nvar rtrimRight = /\\s+$/;\n\nmodule.exports = function parsejson(data) {\n  if ('string' != typeof data || !data) {\n    return null;\n  }\n\n  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');\n\n  // Attempt to parse using the native JSON parser first\n  if (global.JSON && JSON.parse) {\n    return JSON.parse(data);\n  }\n\n  if (rvalidchars.test(data.replace(rvalidescape, '@')\n      .replace(rvalidtokens, ']')\n      .replace(rvalidbraces, ''))) {\n    return (new Function('return ' + data))();\n  }\n};\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],33:[function(_dereq_,module,exports){\n/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\n\nexports.encode = function (obj) {\n  var str = '';\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (str.length) str += '&';\n      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n    }\n  }\n\n  return str;\n};\n\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\n\nexports.decode = function(qs){\n  var qry = {};\n  var pairs = qs.split('&');\n  for (var i = 0, l = pairs.length; i < l; i++) {\n    var pair = pairs[i].split('=');\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n  }\n  return qry;\n};\n\n},{}],34:[function(_dereq_,module,exports){\n/**\n * Parses an URI\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\n\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nvar parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\n\nmodule.exports = function parseuri(str) {\n    var src = str,\n        b = str.indexOf('['),\n        e = str.indexOf(']');\n\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n\n    var m = re.exec(str || ''),\n        uri = {},\n        i = 14;\n\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n\n    return uri;\n};\n\n},{}],35:[function(_dereq_,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar global = (function() { return this; })();\n\n/**\n * WebSocket constructor.\n */\n\nvar WebSocket = global.WebSocket || global.MozWebSocket;\n\n/**\n * Module exports.\n */\n\nmodule.exports = WebSocket ? ws : null;\n\n/**\n * WebSocket constructor.\n *\n * The third `opts` options object gets ignored in web browsers, since it's\n * non-standard, and throws a TypeError if passed to the constructor.\n * See: https://github.com/einaros/ws/issues/227\n *\n * @param {String} uri\n * @param {Array} protocols (optional)\n * @param {Object) opts (optional)\n * @api public\n */\n\nfunction ws(uri, protocols, opts) {\n  var instance;\n  if (protocols) {\n    instance = new WebSocket(uri, protocols);\n  } else {\n    instance = new WebSocket(uri);\n  }\n  return instance;\n}\n\nif (WebSocket) ws.prototype = WebSocket.prototype;\n\n},{}],36:[function(_dereq_,module,exports){\n(function (global){\n\n/*\n * Module requirements.\n */\n\nvar isArray = _dereq_('isarray');\n\n/**\n * Module exports.\n */\n\nmodule.exports = hasBinary;\n\n/**\n * Checks for binary data.\n *\n * Right now only Buffer and ArrayBuffer are supported..\n *\n * @param {Object} anything\n * @api public\n */\n\nfunction hasBinary(data) {\n\n  function _hasBinary(obj) {\n    if (!obj) return false;\n\n    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||\n         (global.Blob && obj instanceof Blob) ||\n         (global.File && obj instanceof File)\n        ) {\n      return true;\n    }\n\n    if (isArray(obj)) {\n      for (var i = 0; i < obj.length; i++) {\n          if (_hasBinary(obj[i])) {\n              return true;\n          }\n      }\n    } else if (obj && 'object' == typeof obj) {\n      if (obj.toJSON) {\n        obj = obj.toJSON();\n      }\n\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return _hasBinary(data);\n}\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"isarray\":37}],37:[function(_dereq_,module,exports){\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n},{}],38:[function(_dereq_,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar global = _dereq_('global');\n\n/**\n * Module exports.\n *\n * Logic borrowed from Modernizr:\n *\n *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n */\n\ntry {\n  module.exports = 'XMLHttpRequest' in global &&\n    'withCredentials' in new global.XMLHttpRequest();\n} catch (err) {\n  // if XMLHttp support is disabled in IE then it will throw\n  // when trying to create\n  module.exports = false;\n}\n\n},{\"global\":39}],39:[function(_dereq_,module,exports){\n\n/**\n * Returns `this`. Execute this without a \"context\" (i.e. without it being\n * attached to an object of the left-hand side), and `this` points to the\n * \"global\" scope of the current JS execution.\n */\n\nmodule.exports = (function () { return this; })();\n\n},{}],40:[function(_dereq_,module,exports){\n\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n},{}],41:[function(_dereq_,module,exports){\n\n/**\n * HOP ref.\n */\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Return own keys in `obj`.\n *\n * @param {Object} obj\n * @return {Array}\n * @api public\n */\n\nexports.keys = Object.keys || function(obj){\n  var keys = [];\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      keys.push(key);\n    }\n  }\n  return keys;\n};\n\n/**\n * Return own values in `obj`.\n *\n * @param {Object} obj\n * @return {Array}\n * @api public\n */\n\nexports.values = function(obj){\n  var vals = [];\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      vals.push(obj[key]);\n    }\n  }\n  return vals;\n};\n\n/**\n * Merge `b` into `a`.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api public\n */\n\nexports.merge = function(a, b){\n  for (var key in b) {\n    if (has.call(b, key)) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n};\n\n/**\n * Return length of `obj`.\n *\n * @param {Object} obj\n * @return {Number}\n * @api public\n */\n\nexports.length = function(obj){\n  return exports.keys(obj).length;\n};\n\n/**\n * Check if `obj` is empty.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api public\n */\n\nexports.isEmpty = function(obj){\n  return 0 == exports.length(obj);\n};\n},{}],42:[function(_dereq_,module,exports){\n/**\n * Parses an URI\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\n\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nvar parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'\n  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\n\nmodule.exports = function parseuri(str) {\n  var m = re.exec(str || '')\n    , uri = {}\n    , i = 14;\n\n  while (i--) {\n    uri[parts[i]] = m[i] || '';\n  }\n\n  return uri;\n};\n\n},{}],43:[function(_dereq_,module,exports){\n(function (global){\n/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = _dereq_('isarray');\nvar isBuf = _dereq_('./is-buffer');\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function(packet){\n  var buffers = [];\n  var packetData = packet.data;\n\n  function _deconstructPacket(data) {\n    if (!data) return data;\n\n    if (isBuf(data)) {\n      var placeholder = { _placeholder: true, num: buffers.length };\n      buffers.push(data);\n      return placeholder;\n    } else if (isArray(data)) {\n      var newData = new Array(data.length);\n      for (var i = 0; i < data.length; i++) {\n        newData[i] = _deconstructPacket(data[i]);\n      }\n      return newData;\n    } else if ('object' == typeof data && !(data instanceof Date)) {\n      var newData = {};\n      for (var key in data) {\n        newData[key] = _deconstructPacket(data[key]);\n      }\n      return newData;\n    }\n    return data;\n  }\n\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {packet: pack, buffers: buffers};\n};\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function(packet, buffers) {\n  var curPlaceHolder = 0;\n\n  function _reconstructPacket(data) {\n    if (data && data._placeholder) {\n      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)\n      return buf;\n    } else if (isArray(data)) {\n      for (var i = 0; i < data.length; i++) {\n        data[i] = _reconstructPacket(data[i]);\n      }\n      return data;\n    } else if (data && 'object' == typeof data) {\n      for (var key in data) {\n        data[key] = _reconstructPacket(data[key]);\n      }\n      return data;\n    }\n    return data;\n  }\n\n  packet.data = _reconstructPacket(packet.data);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function(data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if ((global.Blob && obj instanceof Blob) ||\n        (global.File && obj instanceof File)) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function() { // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        }\n        else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if(! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) { // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./is-buffer\":45,\"isarray\":46}],44:[function(_dereq_,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar debug = _dereq_('debug')('socket.io-parser');\nvar json = _dereq_('json3');\nvar isArray = _dereq_('isarray');\nvar Emitter = _dereq_('component-emitter');\nvar binary = _dereq_('./binary');\nvar isBuf = _dereq_('./is-buffer');\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = [\n  'CONNECT',\n  'DISCONNECT',\n  'EVENT',\n  'BINARY_EVENT',\n  'ACK',\n  'BINARY_ACK',\n  'ERROR'\n];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function(obj, callback){\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n    encodeAsBinary(obj, callback);\n  }\n  else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n  var str = '';\n  var nsp = false;\n\n  // first is type\n  str += obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n    str += obj.attachments;\n    str += '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' != obj.nsp) {\n    nsp = true;\n    str += obj.nsp;\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    if (nsp) {\n      str += ',';\n      nsp = false;\n    }\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    if (nsp) str += ',';\n    str += json.stringify(obj.data);\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an ecoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function(obj) {\n  var packet;\n  if ('string' == typeof obj) {\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else { // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  }\n  else if (isBuf(obj) || obj.base64) { // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) { // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  }\n  else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var p = {};\n  var i = 0;\n\n  // look up type\n  p.type = Number(str.charAt(0));\n  if (null == exports.types[p.type]) return error();\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {\n    var buf = '';\n    while (str.charAt(++i) != '-') {\n      buf += str.charAt(i);\n      if (i == str.length) break;\n    }\n    if (buf != Number(buf) || str.charAt(i) != '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' == str.charAt(i + 1)) {\n    p.nsp = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' == c) break;\n      p.nsp += c;\n      if (i == str.length) break;\n    }\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    p.id = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      p.id += str.charAt(i);\n      if (i == str.length) break;\n    }\n    p.id = Number(p.id);\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    try {\n      p.data = json.parse(str.substr(i));\n    } catch(e){\n      return error();\n    }\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function() {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function() {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(data){\n  return {\n    type: exports.ERROR,\n    data: 'parser error'\n  };\n}\n\n},{\"./binary\":43,\"./is-buffer\":45,\"component-emitter\":9,\"debug\":10,\"isarray\":46,\"json3\":47}],45:[function(_dereq_,module,exports){\n(function (global){\n\nmodule.exports = isBuf;\n\n/**\n * Returns true if obj is a buffer or an arraybuffer.\n *\n * @api private\n */\n\nfunction isBuf(obj) {\n  return (global.Buffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer);\n}\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],46:[function(_dereq_,module,exports){\nmodule.exports=_dereq_(37)\n},{}],47:[function(_dereq_,module,exports){\n/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */\n;(function (window) {\n  // Convenience aliases.\n  var getClass = {}.toString, isProperty, forEach, undef;\n\n  // Detect the `define` function exposed by asynchronous module loaders. The\n  // strict `define` check is necessary for compatibility with `r.js`.\n  var isLoader = typeof define === \"function\" && define.amd;\n\n  // Detect native implementations.\n  var nativeJSON = typeof JSON == \"object\" && JSON;\n\n  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if\n  // available.\n  var JSON3 = typeof exports == \"object\" && exports && !exports.nodeType && exports;\n\n  if (JSON3 && nativeJSON) {\n    // Explicitly delegate to the native `stringify` and `parse`\n    // implementations in CommonJS environments.\n    JSON3.stringify = nativeJSON.stringify;\n    JSON3.parse = nativeJSON.parse;\n  } else {\n    // Export for web browsers, JavaScript engines, and asynchronous module\n    // loaders, using the global `JSON` object if available.\n    JSON3 = window.JSON = nativeJSON || {};\n  }\n\n  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n  var isExtended = new Date(-3509827334573292);\n  try {\n    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n    // results for certain dates in Opera >= 10.53.\n    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n      // Safari < 2.0.2 stores the internal millisecond time value correctly,\n      // but clips the values returned by the date methods to the range of\n      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n  } catch (exception) {}\n\n  // Internal: Determines whether the native `JSON.stringify` and `parse`\n  // implementations are spec-compliant. Based on work by Ken Snyder.\n  function has(name) {\n    if (has[name] !== undef) {\n      // Return cached feature test result.\n      return has[name];\n    }\n\n    var isSupported;\n    if (name == \"bug-string-char-index\") {\n      // IE <= 7 doesn't support accessing string characters using square\n      // bracket notation. IE 8 only supports this for primitives.\n      isSupported = \"a\"[0] != \"a\";\n    } else if (name == \"json\") {\n      // Indicates whether both `JSON.stringify` and `JSON.parse` are\n      // supported.\n      isSupported = has(\"json-stringify\") && has(\"json-parse\");\n    } else {\n      var value, serialized = '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}';\n      // Test `JSON.stringify`.\n      if (name == \"json-stringify\") {\n        var stringify = JSON3.stringify, stringifySupported = typeof stringify == \"function\" && isExtended;\n        if (stringifySupported) {\n          // A test function object with a custom `toJSON` method.\n          (value = function () {\n            return 1;\n          }).toJSON = value;\n          try {\n            stringifySupported =\n              // Firefox 3.1b1 and b2 serialize string, number, and boolean\n              // primitives as object literals.\n              stringify(0) === \"0\" &&\n              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n              // literals.\n              stringify(new Number()) === \"0\" &&\n              stringify(new String()) == '\"\"' &&\n              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n              // does not define a canonical JSON representation (this applies to\n              // objects with `toJSON` properties as well, *unless* they are nested\n              // within an object or array).\n              stringify(getClass) === undef &&\n              // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n              // FF 3.1b3 pass this test.\n              stringify(undef) === undef &&\n              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n              // respectively, if the value is omitted entirely.\n              stringify() === undef &&\n              // FF 3.1b1, 2 throw an error if the given value is not a number,\n              // string, array, object, Boolean, or `null` literal. This applies to\n              // objects with custom `toJSON` methods as well, unless they are nested\n              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n              // methods entirely.\n              stringify(value) === \"1\" &&\n              stringify([value]) == \"[1]\" &&\n              // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n              // `\"[null]\"`.\n              stringify([undef]) == \"[null]\" &&\n              // YUI 3.0.0b1 fails to serialize `null` literals.\n              stringify(null) == \"null\" &&\n              // FF 3.1b1, 2 halts serialization if an array contains a function:\n              // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n              // elides non-JSON values from objects and arrays, unless they\n              // define custom `toJSON` methods.\n              stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n              // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n              stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n              stringify(null, value) === \"1\" &&\n              stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n              // serialize extended years.\n              stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n              // The milliseconds are optional in ES 5, but required in 5.1.\n              stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n              // four-digit years instead of six-digit years. Credits: @Yaffle.\n              stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n              // values less than 1000. Credits: @Yaffle.\n              stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n          } catch (exception) {\n            stringifySupported = false;\n          }\n        }\n        isSupported = stringifySupported;\n      }\n      // Test `JSON.parse`.\n      if (name == \"json-parse\") {\n        var parse = JSON3.parse;\n        if (typeof parse == \"function\") {\n          try {\n            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n            // Conforming implementations should also coerce the initial argument to\n            // a string prior to parsing.\n            if (parse(\"0\") === 0 && !parse(false)) {\n              // Simple parsing test.\n              value = parse(serialized);\n              var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n              if (parseSupported) {\n                try {\n                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                  parseSupported = !parse('\"\\t\"');\n                } catch (exception) {}\n                if (parseSupported) {\n                  try {\n                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n                    // certain octal literals.\n                    parseSupported = parse(\"01\") !== 1;\n                  } catch (exception) {}\n                }\n                if (parseSupported) {\n                  try {\n                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n                    // points. These environments, along with FF 3.1b1 and 2,\n                    // also allow trailing commas in JSON objects and arrays.\n                    parseSupported = parse(\"1.\") !== 1;\n                  } catch (exception) {}\n                }\n              }\n            }\n          } catch (exception) {\n            parseSupported = false;\n          }\n        }\n        isSupported = parseSupported;\n      }\n    }\n    return has[name] = !!isSupported;\n  }\n\n  if (!has(\"json\")) {\n    // Common `[[Class]]` name aliases.\n    var functionClass = \"[object Function]\";\n    var dateClass = \"[object Date]\";\n    var numberClass = \"[object Number]\";\n    var stringClass = \"[object String]\";\n    var arrayClass = \"[object Array]\";\n    var booleanClass = \"[object Boolean]\";\n\n    // Detect incomplete support for accessing string characters by index.\n    var charIndexBuggy = has(\"bug-string-char-index\");\n\n    // Define additional utility methods if the `Date` methods are buggy.\n    if (!isExtended) {\n      var floor = Math.floor;\n      // A mapping between the months of the year and the number of days between\n      // January 1st and the first of the respective month.\n      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n      // Internal: Calculates the number of days between the Unix epoch and the\n      // first day of the given month.\n      var getDay = function (year, month) {\n        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n      };\n    }\n\n    // Internal: Determines if a property is a direct property of the given\n    // object. Delegates to the native `Object#hasOwnProperty` method.\n    if (!(isProperty = {}.hasOwnProperty)) {\n      isProperty = function (property) {\n        var members = {}, constructor;\n        if ((members.__proto__ = null, members.__proto__ = {\n          // The *proto* property cannot be set multiple times in recent\n          // versions of Firefox and SeaMonkey.\n          \"toString\": 1\n        }, members).toString != getClass) {\n          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n          // supports the mutable *proto* property.\n          isProperty = function (property) {\n            // Capture and break the object's prototype chain (see section 8.6.2\n            // of the ES 5.1 spec). The parenthesized expression prevents an\n            // unsafe transformation by the Closure Compiler.\n            var original = this.__proto__, result = property in (this.__proto__ = null, this);\n            // Restore the original prototype chain.\n            this.__proto__ = original;\n            return result;\n          };\n        } else {\n          // Capture a reference to the top-level `Object` constructor.\n          constructor = members.constructor;\n          // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n          // other environments.\n          isProperty = function (property) {\n            var parent = (this.constructor || constructor).prototype;\n            return property in this && !(property in parent && this[property] === parent[property]);\n          };\n        }\n        members = null;\n        return isProperty.call(this, property);\n      };\n    }\n\n    // Internal: A set of primitive types used by `isHostType`.\n    var PrimitiveTypes = {\n      'boolean': 1,\n      'number': 1,\n      'string': 1,\n      'undefined': 1\n    };\n\n    // Internal: Determines if the given object `property` value is a\n    // non-primitive.\n    var isHostType = function (object, property) {\n      var type = typeof object[property];\n      return type == 'object' ? !!object[property] : !PrimitiveTypes[type];\n    };\n\n    // Internal: Normalizes the `for...in` iteration algorithm across\n    // environments. Each enumerated key is yielded to a `callback` function.\n    forEach = function (object, callback) {\n      var size = 0, Properties, members, property;\n\n      // Tests for bugs in the current environment's `for...in` algorithm. The\n      // `valueOf` property inherits the non-enumerable flag from\n      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n      (Properties = function () {\n        this.valueOf = 0;\n      }).prototype.valueOf = 0;\n\n      // Iterate over a new instance of the `Properties` class.\n      members = new Properties();\n      for (property in members) {\n        // Ignore all properties inherited from `Object.prototype`.\n        if (isProperty.call(members, property)) {\n          size++;\n        }\n      }\n      Properties = members = null;\n\n      // Normalize the iteration algorithm.\n      if (!size) {\n        // A list of non-enumerable properties inherited from `Object.prototype`.\n        members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n        // properties.\n        forEach = function (object, callback) {\n          var isFunction = getClass.call(object) == functionClass, property, length;\n          var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;\n          for (property in object) {\n            // Gecko <= 1.0 enumerates the `prototype` property of functions under\n            // certain conditions; IE does not.\n            if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n              callback(property);\n            }\n          }\n          // Manually invoke the callback for each non-enumerable property.\n          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n        };\n      } else if (size == 2) {\n        // Safari <= 2.0.4 enumerates shadowed properties twice.\n        forEach = function (object, callback) {\n          // Create a set of iterated properties.\n          var members = {}, isFunction = getClass.call(object) == functionClass, property;\n          for (property in object) {\n            // Store each property name to prevent double enumeration. The\n            // `prototype` property of functions is not enumerated due to cross-\n            // environment inconsistencies.\n            if (!(isFunction && property == \"prototype\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n              callback(property);\n            }\n          }\n        };\n      } else {\n        // No bugs detected; use the standard `for...in` algorithm.\n        forEach = function (object, callback) {\n          var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n          for (property in object) {\n            if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n              callback(property);\n            }\n          }\n          // Manually invoke the callback for the `constructor` property due to\n          // cross-environment inconsistencies.\n          if (isConstructor || isProperty.call(object, (property = \"constructor\"))) {\n            callback(property);\n          }\n        };\n      }\n      return forEach(object, callback);\n    };\n\n    // Public: Serializes a JavaScript `value` as a JSON string. The optional\n    // `filter` argument may specify either a function that alters how object and\n    // array members are serialized, or an array of strings and numbers that\n    // indicates which properties should be serialized. The optional `width`\n    // argument may be either a string or number that specifies the indentation\n    // level of the output.\n    if (!has(\"json-stringify\")) {\n      // Internal: A map of control characters and their escaped equivalents.\n      var Escapes = {\n        92: \"\\\\\\\\\",\n        34: '\\\\\"',\n        8: \"\\\\b\",\n        12: \"\\\\f\",\n        10: \"\\\\n\",\n        13: \"\\\\r\",\n        9: \"\\\\t\"\n      };\n\n      // Internal: Converts `value` into a zero-padded string such that its\n      // length is at least equal to `width`. The `width` must be <= 6.\n      var leadingZeroes = \"000000\";\n      var toPaddedString = function (width, value) {\n        // The `|| 0` expression is necessary to work around a bug in\n        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n        return (leadingZeroes + (value || 0)).slice(-width);\n      };\n\n      // Internal: Double-quotes a string `value`, replacing all ASCII control\n      // characters (characters with code unit values between 0 and 31) with\n      // their escaped equivalents. This is an implementation of the\n      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n      var unicodePrefix = \"\\\\u00\";\n      var quote = function (value) {\n        var result = '\"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;\n        if (isLarge) {\n          symbols = value.split(\"\");\n        }\n        for (; index < length; index++) {\n          var charCode = value.charCodeAt(index);\n          // If the character is a control character, append its Unicode or\n          // shorthand escape sequence; otherwise, append the character as-is.\n          switch (charCode) {\n            case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n              result += Escapes[charCode];\n              break;\n            default:\n              if (charCode < 32) {\n                result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                break;\n              }\n              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];\n          }\n        }\n        return result + '\"';\n      };\n\n      // Internal: Recursively serializes an object. Implements the\n      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n        try {\n          // Necessary for host object support.\n          value = object[property];\n        } catch (exception) {}\n        if (typeof value == \"object\" && value) {\n          className = getClass.call(value);\n          if (className == dateClass && !isProperty.call(value, \"toJSON\")) {\n            if (value > -1 / 0 && value < 1 / 0) {\n              // Dates are serialized according to the `Date#toJSON` method\n              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n              // for the ISO 8601 date time string format.\n              if (getDay) {\n                // Manually compute the year, month, date, hours, minutes,\n                // seconds, and milliseconds if the `getUTC*` methods are\n                // buggy. Adapted from @Yaffle's `date-shim` project.\n                date = floor(value / 864e5);\n                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n                date = 1 + date - getDay(year, month);\n                // The `time` value specifies the time within the day (see ES\n                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                // to compute `A modulo B`, as the `%` operator does not\n                // correspond to the `modulo` operation for negative numbers.\n                time = (value % 864e5 + 864e5) % 864e5;\n                // The hours, minutes, seconds, and milliseconds are obtained by\n                // decomposing the time within the day. See section 15.9.1.10.\n                hours = floor(time / 36e5) % 24;\n                minutes = floor(time / 6e4) % 60;\n                seconds = floor(time / 1e3) % 60;\n                milliseconds = time % 1e3;\n              } else {\n                year = value.getUTCFullYear();\n                month = value.getUTCMonth();\n                date = value.getUTCDate();\n                hours = value.getUTCHours();\n                minutes = value.getUTCMinutes();\n                seconds = value.getUTCSeconds();\n                milliseconds = value.getUTCMilliseconds();\n              }\n              // Serialize extended years correctly.\n              value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n                \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n                // Months, dates, hours, minutes, and seconds should have two\n                // digits; milliseconds should have three.\n                \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n                // Milliseconds are optional in ES 5.0, but required in 5.1.\n                \".\" + toPaddedString(3, milliseconds) + \"Z\";\n            } else {\n              value = null;\n            }\n          } else if (typeof value.toJSON == \"function\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \"toJSON\"))) {\n            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n            // ignores all `toJSON` methods on these objects unless they are\n            // defined directly on an instance.\n            value = value.toJSON(property);\n          }\n        }\n        if (callback) {\n          // If a replacement function was provided, call it to obtain the value\n          // for serialization.\n          value = callback.call(object, property, value);\n        }\n        if (value === null) {\n          return \"null\";\n        }\n        className = getClass.call(value);\n        if (className == booleanClass) {\n          // Booleans are represented literally.\n          return \"\" + value;\n        } else if (className == numberClass) {\n          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n          // `\"null\"`.\n          return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n        } else if (className == stringClass) {\n          // Strings are double-quoted and escaped.\n          return quote(\"\" + value);\n        }\n        // Recursively serialize objects and arrays.\n        if (typeof value == \"object\") {\n          // Check for cyclic structures. This is a linear search; performance\n          // is inversely proportional to the number of unique nested objects.\n          for (length = stack.length; length--;) {\n            if (stack[length] === value) {\n              // Cyclic structures cannot be serialized by `JSON.stringify`.\n              throw TypeError();\n            }\n          }\n          // Add the object to the stack of traversed objects.\n          stack.push(value);\n          results = [];\n          // Save the current indentation level and indent one additional level.\n          prefix = indentation;\n          indentation += whitespace;\n          if (className == arrayClass) {\n            // Recursively serialize array elements.\n            for (index = 0, length = value.length; index < length; index++) {\n              element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n              results.push(element === undef ? \"null\" : element);\n            }\n            result = results.length ? (whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : (\"[\" + results.join(\",\") + \"]\")) : \"[]\";\n          } else {\n            // Recursively serialize object members. Members are selected from\n            // either a user-specified list of property names, or the object\n            // itself.\n            forEach(properties || value, function (property) {\n              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n              if (element !== undef) {\n                // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n                // is not the empty string, let `member` {quote(property) + \":\"}\n                // be the concatenation of `member` and the `space` character.\"\n                // The \"`space` character\" refers to the literal space\n                // character, not the `space` {width} argument provided to\n                // `JSON.stringify`.\n                results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n              }\n            });\n            result = results.length ? (whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : (\"{\" + results.join(\",\") + \"}\")) : \"{}\";\n          }\n          // Remove the object from the traversed object stack.\n          stack.pop();\n          return result;\n        }\n      };\n\n      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n      JSON3.stringify = function (source, filter, width) {\n        var whitespace, callback, properties, className;\n        if (typeof filter == \"function\" || typeof filter == \"object\" && filter) {\n          if ((className = getClass.call(filter)) == functionClass) {\n            callback = filter;\n          } else if (className == arrayClass) {\n            // Convert the property names array into a makeshift set.\n            properties = {};\n            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n          }\n        }\n        if (width) {\n          if ((className = getClass.call(width)) == numberClass) {\n            // Convert the `width` to an integer and create a string containing\n            // `width` number of space characters.\n            if ((width -= width % 1) > 0) {\n              for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \");\n            }\n          } else if (className == stringClass) {\n            whitespace = width.length <= 10 ? width : width.slice(0, 10);\n          }\n        }\n        // Opera <= 7.54u2 discards the values associated with empty string keys\n        // (`\"\"`) only if they are used directly within an object member list\n        // (e.g., `!(\"\" in { \"\": 1})`).\n        return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n      };\n    }\n\n    // Public: Parses a JSON source string.\n    if (!has(\"json-parse\")) {\n      var fromCharCode = String.fromCharCode;\n\n      // Internal: A map of escaped control characters and their unescaped\n      // equivalents.\n      var Unescapes = {\n        92: \"\\\\\",\n        34: '\"',\n        47: \"/\",\n        98: \"\\b\",\n        116: \"\\t\",\n        110: \"\\n\",\n        102: \"\\f\",\n        114: \"\\r\"\n      };\n\n      // Internal: Stores the parser state.\n      var Index, Source;\n\n      // Internal: Resets the parser state and throws a `SyntaxError`.\n      var abort = function() {\n        Index = Source = null;\n        throw SyntaxError();\n      };\n\n      // Internal: Returns the next token, or `\"$\"` if the parser has reached\n      // the end of the source string. A token may be a string, number, `null`\n      // literal, or Boolean literal.\n      var lex = function () {\n        var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n        while (Index < length) {\n          charCode = source.charCodeAt(Index);\n          switch (charCode) {\n            case 9: case 10: case 13: case 32:\n              // Skip whitespace tokens, including tabs, carriage returns, line\n              // feeds, and space characters.\n              Index++;\n              break;\n            case 123: case 125: case 91: case 93: case 58: case 44:\n              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n              // the current position.\n              value = charIndexBuggy ? source.charAt(Index) : source[Index];\n              Index++;\n              return value;\n            case 34:\n              // `\"` delimits a JSON string; advance to the next character and\n              // begin parsing the string. String tokens are prefixed with the\n              // sentinel `@` character to distinguish them from punctuators and\n              // end-of-string tokens.\n              for (value = \"@\", Index++; Index < length;) {\n                charCode = source.charCodeAt(Index);\n                if (charCode < 32) {\n                  // Unescaped ASCII control characters (those with a code unit\n                  // less than the space character) are not permitted.\n                  abort();\n                } else if (charCode == 92) {\n                  // A reverse solidus (`\\`) marks the beginning of an escaped\n                  // control character (including `\"`, `\\`, and `/`) or Unicode\n                  // escape sequence.\n                  charCode = source.charCodeAt(++Index);\n                  switch (charCode) {\n                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n                      // Revive escaped control characters.\n                      value += Unescapes[charCode];\n                      Index++;\n                      break;\n                    case 117:\n                      // `\\u` marks the beginning of a Unicode escape sequence.\n                      // Advance to the first character and validate the\n                      // four-digit code point.\n                      begin = ++Index;\n                      for (position = Index + 4; Index < position; Index++) {\n                        charCode = source.charCodeAt(Index);\n                        // A valid sequence comprises four hexdigits (case-\n                        // insensitive) that form a single hexadecimal value.\n                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                          // Invalid Unicode escape sequence.\n                          abort();\n                        }\n                      }\n                      // Revive the escaped character.\n                      value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                      break;\n                    default:\n                      // Invalid escape sequence.\n                      abort();\n                  }\n                } else {\n                  if (charCode == 34) {\n                    // An unescaped double-quote character marks the end of the\n                    // string.\n                    break;\n                  }\n                  charCode = source.charCodeAt(Index);\n                  begin = Index;\n                  // Optimize for the common case where a string is valid.\n                  while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                    charCode = source.charCodeAt(++Index);\n                  }\n                  // Append the string as-is.\n                  value += source.slice(begin, Index);\n                }\n              }\n              if (source.charCodeAt(Index) == 34) {\n                // Advance to the next character and return the revived string.\n                Index++;\n                return value;\n              }\n              // Unterminated string.\n              abort();\n            default:\n              // Parse numbers and literals.\n              begin = Index;\n              // Advance past the negative sign, if one is specified.\n              if (charCode == 45) {\n                isSigned = true;\n                charCode = source.charCodeAt(++Index);\n              }\n              // Parse an integer or floating-point value.\n              if (charCode >= 48 && charCode <= 57) {\n                // Leading zeroes are interpreted as octal literals.\n                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n                  // Illegal octal literal.\n                  abort();\n                }\n                isSigned = false;\n                // Parse the integer component.\n                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n                // Floats cannot contain a leading decimal point; however, this\n                // case is already accounted for by the parser.\n                if (source.charCodeAt(Index) == 46) {\n                  position = ++Index;\n                  // Parse the decimal component.\n                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                  if (position == Index) {\n                    // Illegal trailing decimal.\n                    abort();\n                  }\n                  Index = position;\n                }\n                // Parse exponents. The `e` denoting the exponent is\n                // case-insensitive.\n                charCode = source.charCodeAt(Index);\n                if (charCode == 101 || charCode == 69) {\n                  charCode = source.charCodeAt(++Index);\n                  // Skip past the sign following the exponent, if one is\n                  // specified.\n                  if (charCode == 43 || charCode == 45) {\n                    Index++;\n                  }\n                  // Parse the exponential component.\n                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                  if (position == Index) {\n                    // Illegal empty exponent.\n                    abort();\n                  }\n                  Index = position;\n                }\n                // Coerce the parsed value to a JavaScript number.\n                return +source.slice(begin, Index);\n              }\n              // A negative sign may only precede numbers.\n              if (isSigned) {\n                abort();\n              }\n              // `true`, `false`, and `null` literals.\n              if (source.slice(Index, Index + 4) == \"true\") {\n                Index += 4;\n                return true;\n              } else if (source.slice(Index, Index + 5) == \"false\") {\n                Index += 5;\n                return false;\n              } else if (source.slice(Index, Index + 4) == \"null\") {\n                Index += 4;\n                return null;\n              }\n              // Unrecognized token.\n              abort();\n          }\n        }\n        // Return the sentinel `$` character if the parser has reached the end\n        // of the source string.\n        return \"$\";\n      };\n\n      // Internal: Parses a JSON `value` token.\n      var get = function (value) {\n        var results, hasMembers;\n        if (value == \"$\") {\n          // Unexpected end of input.\n          abort();\n        }\n        if (typeof value == \"string\") {\n          if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n            // Remove the sentinel `@` character.\n            return value.slice(1);\n          }\n          // Parse object and array literals.\n          if (value == \"[\") {\n            // Parses a JSON array, returning a new JavaScript array.\n            results = [];\n            for (;; hasMembers || (hasMembers = true)) {\n              value = lex();\n              // A closing square bracket marks the end of the array literal.\n              if (value == \"]\") {\n                break;\n              }\n              // If the array literal contains elements, the current token\n              // should be a comma separating the previous element from the\n              // next.\n              if (hasMembers) {\n                if (value == \",\") {\n                  value = lex();\n                  if (value == \"]\") {\n                    // Unexpected trailing `,` in array literal.\n                    abort();\n                  }\n                } else {\n                  // A `,` must separate each array element.\n                  abort();\n                }\n              }\n              // Elisions and leading commas are not permitted.\n              if (value == \",\") {\n                abort();\n              }\n              results.push(get(value));\n            }\n            return results;\n          } else if (value == \"{\") {\n            // Parses a JSON object, returning a new JavaScript object.\n            results = {};\n            for (;; hasMembers || (hasMembers = true)) {\n              value = lex();\n              // A closing curly brace marks the end of the object literal.\n              if (value == \"}\") {\n                break;\n              }\n              // If the object literal contains members, the current token\n              // should be a comma separator.\n              if (hasMembers) {\n                if (value == \",\") {\n                  value = lex();\n                  if (value == \"}\") {\n                    // Unexpected trailing `,` in object literal.\n                    abort();\n                  }\n                } else {\n                  // A `,` must separate each object member.\n                  abort();\n                }\n              }\n              // Leading commas are not permitted, object property names must be\n              // double-quoted strings, and a `:` must separate each property\n              // name and value.\n              if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n                abort();\n              }\n              results[value.slice(1)] = get(lex());\n            }\n            return results;\n          }\n          // Unexpected token encountered.\n          abort();\n        }\n        return value;\n      };\n\n      // Internal: Updates a traversed object member.\n      var update = function(source, property, callback) {\n        var element = walk(source, property, callback);\n        if (element === undef) {\n          delete source[property];\n        } else {\n          source[property] = element;\n        }\n      };\n\n      // Internal: Recursively traverses a parsed JSON object, invoking the\n      // `callback` function for each value. This is an implementation of the\n      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n      var walk = function (source, property, callback) {\n        var value = source[property], length;\n        if (typeof value == \"object\" && value) {\n          // `forEach` can't be used to traverse an array in Opera <= 8.54\n          // because its `Object#hasOwnProperty` implementation returns `false`\n          // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n          if (getClass.call(value) == arrayClass) {\n            for (length = value.length; length--;) {\n              update(value, length, callback);\n            }\n          } else {\n            forEach(value, function (property) {\n              update(value, property, callback);\n            });\n          }\n        }\n        return callback.call(source, property, value);\n      };\n\n      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n      JSON3.parse = function (source, callback) {\n        var result, value;\n        Index = 0;\n        Source = \"\" + source;\n        result = get(lex());\n        // If a JSON string contains multiple tokens, it is invalid.\n        if (lex() != \"$\") {\n          abort();\n        }\n        // Reset the parser state.\n        Index = Source = null;\n        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n      };\n    }\n  }\n\n  // Export for asynchronous module loaders.\n  if (isLoader) {\n    define(function () {\n      return JSON3;\n    });\n  }\n}(this));\n\n},{}],48:[function(_dereq_,module,exports){\nmodule.exports = toArray\n\nfunction toArray(list, index) {\n    var array = []\n\n    index = index || 0\n\n    for (var i = index || 0; i < list.length; i++) {\n        array[i - index] = list[i]\n    }\n\n    return array\n}\n\n},{}]},{},[1])\n(1)\n});"}